
\section{Motivating Example}

We illustrate the idea of deep parameters with an example found by our approach for \emph{dlmalloc} (version 2.8.6) \cite{lea1996memory}.

\begin{figure}[ht]
\lstset{numbers=left, escapeinside={(*@}{@*)}}
\begin{lstlisting}
static void* sys_alloc(mstate m,size_t nb) {
...
	if (ss == 0){ //check if first time through
		char* base = (char*)CALL_MORECORE(0); (*@\label{call_morecore}@*)
	...
}
\end{lstlisting}
\vspace{-1.5em}
\caption{{\tt sys\_alloc} function in \emph{dlmalloc}}
\label{exp}
\end{figure}

Figure \ref{exp} shows a part of the {\tt sys\_alloc} function in \emph{dlmalloc}. We explain its internal operation here to illustrate to the reader that this clearly is a non-trivial optimisation problem. Of course, our parameter exposing and search-based tuning are general purpose techniques that have no knowledge of how \emph{dlmalloc} operates. To efficiently manage memory, \emph{dlmalloc} maintains an internal structure to organize the heap for memory reuse. Only when \emph{dlmalloc} cannot find a suitable chunk of memory for a memory request, does it call {\tt sys\_alloc()} to extend the current heap.

After applying the mutation analysis, we found mutants generated from mutating Line \ref{call_morecore} have a notable affect on the memory consumption and the execution time of \emph{dlmalloc}. We take a close took at Line \ref{call_morecore}. It calls the {\tt CALL\_MORECORE()} function, which takes an integer as input, when first time \emph{malloc} is called to obtain the beginning address of the heap. {\tt CALL\_MORECORE()} is a macro which links to the system call that extends or shrinks the current heap and returns the beginning address of the newly allocated region of heap. Specially, {\tt CALL\_MORECORE(0)} neither extends nor shrinks the heap but simply returns the current address of the heap, which is the original purpose of Line 6 mentioned above.

Changing the input value for {\tt CALL\_MORECORE()} in Line \ref{call_morecore} allows us to control the amount of pre-allocated memory. However, although \emph{dlmalloc} provides several tuneable parameters to programmers, allowing them to adjust behaviors (see Section 5 for details), none of these shallow parameters can affect the {\tt CALL\_MORECORE()} function directly. To expose a deep parameter $D$, our tool would transform Line \ref{call_morecore} into the code below, where $D$ is the deep parameter exposed for users to control the pre-allocated heap.

\begin{lstlisting}
char * base = (char*)CALL_MORECORE(0 + D);
\end{lstlisting}

The proper size of pre-allocated memory depends on the specific program using this memory allocator. If the pre-allocated memory is too large, it could be a waste of memory. On the other hand, if it's too small, soon \emph{dlmalloc} will call {\tt CALL\_MORECORE()} again to extend the heap, thus wasting time. By tuning the deep parameter $D$, users can balance the time and space consumption. This is one example of a potential deep parameter. In our mutation analysis experiments, our tool ``discovers'' that by changing the value of this deep parameter, it can reduce 2.5\% of execution time without wasting more space in one of our subjects.

