
\section{Motivating Example}

We illustrate the idea of deep parameters with an example found by our approach for \emph{dlmalloc}.

\begin{figure}[ht]
\begin{lstlisting}
1 static void* sys_alloc(mstate m,size_t nb) 
2 {
3 ...
4 if (ss == 0) //check if first time through
5 { 
6     char* base = (char*)CALL_MORECORE(0);
7 ...
8 }
\end{lstlisting}
\vspace{-1.5em}
\caption{\emph{sys\_alloc} function in \emph{dlmalloc}}
\label{exp}
\end{figure}

Figure \ref{exp} shows a part of the \emph{sys\_alloc} function in \emph{dlmalloc}. We explain its internal operation here to illustrate to the reader that this clearly is a non-trivial optimisation problem. Of course, our parameter exposing and search-based tuning are general purpose techniques that have no knowledge of how \emph{dlmalloc} operates. To efficiently manage memory, \emph{dlmalloc} maintains an internal structure to organize the heap for memory reuse. Only when \emph{dlmalloc} cannot find a suitable chunk of memory for a memory request, does it call \emph{sys\_alloc()} to extend the current heap.

After applying the mutation analysis, we found mutants generated from mutating Line 6 have a notable affect on the memory consumption and the execution time of \emph{dlmalloc}. We take a close took at Line 6. It calls the \emph{CALL\_MORECORE}() function, which takes an integer as input. $CALL\_MORECORE()$ is a system call which extends or shrinks the current heap and returns the new address of the heap. $CALL\_MORECORE(0)$ neither extends nor shrinks the heap but simple returns the current address of heap, which is the original purpose of Line 6 mentioned above.
%In line 4, the $ss == 0$ return true if $sys_alloc$ is the first time being invoked, so line 6 can only be executed once at the beginning.

Thus changing the input value for $CALL\_MORECORE()$ in Line 6 allows us to control the amount of pre-allocated memory. However, although \emph{dlmalloc} provides several tuneable parameters to programmers, allowing them to adjust behaviors (see Section 5 for details), none of these shallow parameters can affect the $CALL\_MORECORE()$ function directly. To exposed a deep parameter $D$, our tool would transform Line 6 into the code below, where $D$ is the deep parameter exposed for users to control the pre-allocated heap.

\begin{lstlisting}
char * base = (char*)CALL_MORECORE(0 + D);
\end{lstlisting}

The proper size of pre-allocated memory depends on the specific program using this memory allocator. If the pre-allocated memory is too large, it could be a waste of memory. On the other hand, if it's too small, soon \emph{dlmalloc} will call $CALL\_MORECORE()$ again to extend the heap, thus wasting time. By tuning the deep parameter $D$, users can balance the time and space consumption. This is one example of a potential deep parameter. In our mutation analysis experiments, our tool ``discovers'' that changing the value of this deep parameter, it can reduce \#\% to \#\% of memory consumption in two of our subjects.

