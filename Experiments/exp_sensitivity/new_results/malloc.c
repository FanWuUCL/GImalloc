#1 "malloc_.c"
#1 "<built-in>"
#1 "<command-line>"
#1 "malloc_.c"
#581 "malloc_.c"
#1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
#26 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
#1 "/usr/include/features.h" 1 3 4
#324 "/usr/include/features.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/predefs.h" 1 3 4
#325 "/usr/include/features.h" 2 3 4
#357 "/usr/include/features.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
#378 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#379 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
#358 "/usr/include/features.h" 2 3 4
#389 "/usr/include/features.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4



#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#5 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4




#1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
#10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
#390 "/usr/include/features.h" 2 3 4
#27 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



#1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
#28 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
#131 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
#132 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct
{
  int __val[2];
} __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void *__timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
#31 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
#61 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;
#99 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
#133 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
#1 "/usr/include/time.h" 1 3 4
#58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



#74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



#92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
#104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
#134 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
#147 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
#1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
#212 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3 4
typedef long unsigned int size_t;
#148 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
#195 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
#217 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
#1 "/usr/include/endian.h" 1 3 4
#37 "/usr/include/endian.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
#38 "/usr/include/endian.h" 2 3 4
#61 "/usr/include/endian.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
#28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
#62 "/usr/include/endian.h" 2 3 4
#218 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


#1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
#31 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
#23 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#24 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
#32 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


#1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
#24 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
#35 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





#1 "/usr/include/time.h" 1 3 4
#120 "/usr/include/time.h" 3 4
struct timespec
{
  __time_t tv_sec;
  long int tv_nsec;
};
#45 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

#1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
#31 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
#47 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
#65 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
{






  __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


}
fd_set;






typedef __fd_mask fd_mask;
#97 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

#107 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set * __restrict __readfds,
		   fd_set * __restrict __writefds,
		   fd_set * __restrict __exceptfds,
		   struct timeval *__restrict __timeout);
#119 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set * __restrict __readfds,
		    fd_set * __restrict __writefds,
		    fd_set * __restrict __exceptfds,
		    const struct timespec *__restrict __timeout,
		    const __sigset_t * __restrict __sigmask);
#132 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

#221 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


#1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
#30 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4


__extension__
  extern unsigned int gnu_dev_major (unsigned long long int __dev)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));
__extension__
  extern unsigned int gnu_dev_minor (unsigned long long int __dev)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));
__extension__
  extern unsigned long long int gnu_dev_makedev (unsigned int __major,
						 unsigned int __minor)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));
#64 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4

#224 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
#271 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
#23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
#50 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[56];
  long int __align;
} pthread_attr_t;



typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
#76 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
#101 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;
  } __data;
#187 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
#272 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



#582 "malloc_.c" 2
#763 "malloc_.c"
struct mallinfo
{
  size_t arena;
  size_t ordblks;
  size_t smblks;
  size_t hblks;
  size_t hblkhd;
  size_t usmblks;
  size_t fsmblks;
  size_t uordblks;
  size_t fordblks;
  size_t keepcost;
};
#854 "malloc_.c"
extern void *malloc (size_t);
#863 "malloc_.c"
extern void free (void *);






extern void *calloc (size_t, size_t);
#894 "malloc_.c"
extern void *realloc (void *, size_t);
#909 "malloc_.c"
extern void *realloc_in_place (void *, size_t);
#923 "malloc_.c"
extern void *memalign (size_t, size_t);
#933 "malloc_.c"
extern int posix_memalign (void **, size_t, size_t);






extern void *valloc (size_t);
#964 "malloc_.c"
extern int mallopt (int, int);
#975 "malloc_.c"
extern size_t malloc_footprint (void);
#988 "malloc_.c"
extern size_t malloc_max_footprint (void);
#999 "malloc_.c"
extern size_t malloc_footprint_limit ();
#1013 "malloc_.c"
extern size_t malloc_set_footprint_limit (size_t bytes);
#1072 "malloc_.c"
extern struct mallinfo mallinfo (void);
#1124 "malloc_.c"
extern void **independent_calloc (size_t, size_t, void **);
#1182 "malloc_.c"
extern void **independent_comalloc (size_t, size_t *, void **);
#1193 "malloc_.c"
extern size_t bulk_free (void **, size_t n_elements);






extern void *pvalloc (size_t);
#1223 "malloc_.c"
extern int malloc_trim (size_t);
#1244 "malloc_.c"
extern void malloc_stats (void);
#1260 "malloc_.c"
size_t malloc_usable_size (void *);
#1436 "malloc_.c"
#1 "/usr/include/stdio.h" 1 3 4
#30 "/usr/include/stdio.h" 3 4




#1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
#35 "/usr/include/stdio.h" 2 3 4
#45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





#65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
#75 "/usr/include/stdio.h" 3 4
#1 "/usr/include/libio.h" 1 3 4
#32 "/usr/include/libio.h" 3 4
#1 "/usr/include/_G_config.h" 1 3 4
#15 "/usr/include/_G_config.h" 3 4
#1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
#16 "/usr/include/_G_config.h" 2 3 4




#1 "/usr/include/wchar.h" 1 3 4
#83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
#21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
#53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
#33 "/usr/include/libio.h" 2 3 4
#53 "/usr/include/libio.h" 3 4
#1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h" 1 3 4
#40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
#54 "/usr/include/libio.h" 2 3 4
#172 "/usr/include/libio.h" 3 4
struct _IO_jump_t;
struct _IO_FILE;
#182 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker
{
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
#205 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
#273 "/usr/include/libio.h" 3 4
struct _IO_FILE
{
  int _flags;




  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
#321 "/usr/include/libio.h" 3 4
  __off64_t _offset;
#330 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
#366 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
				 size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t * __pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile,
			     int __read_write, void *__cookie,
			     _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
#462 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE * __fp);
extern int _IO_putc (int __c, _IO_FILE * __fp);
extern int _IO_feof (_IO_FILE * __fp) __attribute__ ((__nothrow__, __leaf__));
extern int _IO_ferror (_IO_FILE * __fp)
  __attribute__ ((__nothrow__, __leaf__));

extern int _IO_peekc_locked (_IO_FILE * __fp);





extern void _IO_flockfile (_IO_FILE *)
  __attribute__ ((__nothrow__, __leaf__));
extern void _IO_funlockfile (_IO_FILE *)
  __attribute__ ((__nothrow__, __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *)
  __attribute__ ((__nothrow__, __leaf__));
#492 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char *__restrict,
			__gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE * __restrict, const char *__restrict,
			 __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *)
  __attribute__ ((__nothrow__, __leaf__));
#76 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
#109 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;




#165 "/usr/include/stdio.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
#166 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename)
  __attribute__ ((__nothrow__, __leaf__));

extern int rename (__const char *__old, __const char *__new)
  __attribute__ ((__nothrow__, __leaf__));




extern int renameat (int __oldfd, __const char *__old, int __newfd,
		     __const char *__new)
  __attribute__ ((__nothrow__, __leaf__));








extern FILE *tmpfile (void);
#210 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__, __leaf__));





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__, __leaf__));
#228 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__malloc__));








extern int fclose (FILE * __stream);




extern int fflush (FILE * __stream);

#253 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE * __stream);
#267 "/usr/include/stdio.h" 3 4






extern FILE *fopen (__const char *__restrict __filename,
		    __const char *__restrict __modes);




extern FILE *freopen (__const char *__restrict __filename,
		      __const char *__restrict __modes,
		      FILE * __restrict __stream);
#296 "/usr/include/stdio.h" 3 4

#307 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, __const char *__modes)
  __attribute__ ((__nothrow__, __leaf__));
#320 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  __attribute__ ((__nothrow__, __leaf__));




extern FILE *open_memstream (char **__bufloc, size_t * __sizeloc)
  __attribute__ ((__nothrow__, __leaf__));






extern void setbuf (FILE * __restrict __stream, char *__restrict __buf)
  __attribute__ ((__nothrow__, __leaf__));



extern int setvbuf (FILE * __restrict __stream, char *__restrict __buf,
		    int __modes, size_t __n)
  __attribute__ ((__nothrow__, __leaf__));





extern void setbuffer (FILE * __restrict __stream, char *__restrict __buf,
		       size_t __size) __attribute__ ((__nothrow__, __leaf__));


extern void setlinebuf (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));








extern int fprintf (FILE * __restrict __stream,
		    __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
		    __const char *__restrict __format, ...)
  __attribute__ ((__nothrow__));





extern int vfprintf (FILE * __restrict __s, __const char *__restrict __format,
		     __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
		     __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
		     __const char *__restrict __format, ...)
  __attribute__ ((__nothrow__))
  __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
		      __const char *__restrict __format, __gnuc_va_list __arg)
  __attribute__ ((__nothrow__))
  __attribute__ ((__format__ (__printf__, 3, 0)));

#418 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, __const char *__restrict __fmt,
		     __gnuc_va_list __arg)
  __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
  __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE * __restrict __stream,
		   __const char *__restrict __format, ...);




extern int scanf (__const char *__restrict __format, ...);

extern int sscanf (__const char *__restrict __s,
		   __const char *__restrict __format, ...)
  __attribute__ ((__nothrow__, __leaf__));
#449 "/usr/include/stdio.h" 3 4
extern int
fscanf (FILE * __restrict __stream, __const char *__restrict __format, ...)
__asm__ ("" "__isoc99_fscanf");
     extern int scanf (__const char *__restrict __format,
		       ...) __asm__ ("" "__isoc99_scanf");
     extern int sscanf (__const char *__restrict __s,
			__const char *__restrict __format,
			...) __asm__ ("" "__isoc99_sscanf")
  __attribute__ ((__nothrow__, __leaf__));
#469 "/usr/include/stdio.h" 3 4








     extern int vfscanf (FILE * __restrict __s,
			 __const char *__restrict __format,
			 __gnuc_va_list __arg)
  __attribute__ ((__format__ (__scanf__, 2, 0)));





     extern int vscanf (__const char *__restrict __format,
			__gnuc_va_list __arg)
  __attribute__ ((__format__ (__scanf__, 1, 0)));


     extern int vsscanf (__const char *__restrict __s,
			 __const char *__restrict __format,
			 __gnuc_va_list __arg)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__format__ (__scanf__, 2, 0)));
#500 "/usr/include/stdio.h" 3 4
     extern int vfscanf (FILE * __restrict __s,
			 __const char *__restrict __format,
			 __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")
  __attribute__ ((__format__ (__scanf__, 2, 0)));
     extern int vscanf (__const char *__restrict __format,
			__gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")
  __attribute__ ((__format__ (__scanf__, 1, 0)));
     extern int vsscanf (__const char *__restrict __s,
			 __const char *__restrict __format,
			 __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf")
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__format__ (__scanf__, 2, 0)));
#528 "/usr/include/stdio.h" 3 4









     extern int fgetc (FILE * __stream);
     extern int getc (FILE * __stream);





     extern int getchar (void);

#556 "/usr/include/stdio.h" 3 4
     extern int getc_unlocked (FILE * __stream);
     extern int getchar_unlocked (void);
#567 "/usr/include/stdio.h" 3 4
     extern int fgetc_unlocked (FILE * __stream);











     extern int fputc (int __c, FILE * __stream);
     extern int putc (int __c, FILE * __stream);





     extern int putchar (int __c);

#600 "/usr/include/stdio.h" 3 4
     extern int fputc_unlocked (int __c, FILE * __stream);







     extern int putc_unlocked (int __c, FILE * __stream);
     extern int putchar_unlocked (int __c);






     extern int getw (FILE * __stream);


     extern int putw (int __w, FILE * __stream);








     extern char *fgets (char *__restrict __s, int __n,
			 FILE * __restrict __stream);






     extern char *gets (char *__s);

#662 "/usr/include/stdio.h" 3 4
     extern __ssize_t __getdelim (char **__restrict __lineptr,
				  size_t * __restrict __n, int __delimiter,
				  FILE * __restrict __stream);
     extern __ssize_t getdelim (char **__restrict __lineptr,
				size_t * __restrict __n, int __delimiter,
				FILE * __restrict __stream);







     extern __ssize_t getline (char **__restrict __lineptr,
			       size_t * __restrict __n,
			       FILE * __restrict __stream);








     extern int fputs (__const char *__restrict __s,
		       FILE * __restrict __stream);





     extern int puts (__const char *__s);






     extern int ungetc (int __c, FILE * __stream);






     extern size_t fread (void *__restrict __ptr, size_t __size,
			  size_t __n, FILE * __restrict __stream);




     extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
			   size_t __n, FILE * __restrict __s);

#734 "/usr/include/stdio.h" 3 4
     extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
				   size_t __n, FILE * __restrict __stream);
     extern size_t fwrite_unlocked (__const void *__restrict __ptr,
				    size_t __size, size_t __n,
				    FILE * __restrict __stream);








     extern int fseek (FILE * __stream, long int __off, int __whence);




     extern long int ftell (FILE * __stream);




     extern void rewind (FILE * __stream);

#770 "/usr/include/stdio.h" 3 4
     extern int fseeko (FILE * __stream, __off_t __off, int __whence);




     extern __off_t ftello (FILE * __stream);
#789 "/usr/include/stdio.h" 3 4






     extern int fgetpos (FILE * __restrict __stream,
			 fpos_t * __restrict __pos);




     extern int fsetpos (FILE * __stream, __const fpos_t * __pos);
#812 "/usr/include/stdio.h" 3 4

#821 "/usr/include/stdio.h" 3 4


     extern void clearerr (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));

     extern int feof (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));

     extern int ferror (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));




     extern void clearerr_unlocked (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));
     extern int feof_unlocked (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));
     extern int ferror_unlocked (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));








     extern void perror (__const char *__s);






#1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
#27 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
     extern int sys_nerr;
     extern __const char *__const sys_errlist[];
#851 "/usr/include/stdio.h" 2 3 4




     extern int fileno (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));




     extern int fileno_unlocked (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));
#870 "/usr/include/stdio.h" 3 4
     extern FILE *popen (__const char *__command, __const char *__modes);





     extern int pclose (FILE * __stream);





     extern char *ctermid (char *__s) __attribute__ ((__nothrow__, __leaf__));
#910 "/usr/include/stdio.h" 3 4
     extern void flockfile (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));



     extern int ftrylockfile (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));


     extern void funlockfile (FILE * __stream)
  __attribute__ ((__nothrow__, __leaf__));
#940 "/usr/include/stdio.h" 3 4

#1437 "malloc_.c" 2


#1 "/usr/include/errno.h" 1 3 4
#32 "/usr/include/errno.h" 3 4




#1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
#25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
#1 "/usr/include/linux/errno.h" 1 3 4



#1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
#1 "/usr/include/asm-generic/errno.h" 1 3 4



#1 "/usr/include/asm-generic/errno-base.h" 1 3 4
#5 "/usr/include/asm-generic/errno.h" 2 3 4
#1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
#5 "/usr/include/linux/errno.h" 2 3 4
#26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
#47 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
     extern int *__errno_location (void)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));
#37 "/usr/include/errno.h" 2 3 4
#59 "/usr/include/errno.h" 3 4

#1440 "malloc_.c" 2
#1455 "malloc_.c"
#1 "/usr/include/time.h" 1 3 4
#30 "/usr/include/time.h" 3 4








#1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
#39 "/usr/include/time.h" 2 3 4



#1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
#43 "/usr/include/time.h" 2 3 4
#131 "/usr/include/time.h" 3 4


     struct tm
     {
       int tm_sec;
       int tm_min;
       int tm_hour;
       int tm_mday;
       int tm_mon;
       int tm_year;
       int tm_wday;
       int tm_yday;
       int tm_isdst;


       long int tm_gmtoff;
       __const char *tm_zone;




     };








     struct itimerspec
     {
       struct timespec it_interval;
       struct timespec it_value;
     };


     struct sigevent;
#180 "/usr/include/time.h" 3 4



     extern clock_t clock (void) __attribute__ ((__nothrow__, __leaf__));


     extern time_t time (time_t * __timer)
  __attribute__ ((__nothrow__, __leaf__));


     extern double difftime (time_t __time1, time_t __time0)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));


     extern time_t mktime (struct tm *__tp)
  __attribute__ ((__nothrow__, __leaf__));





     extern size_t strftime (char *__restrict __s, size_t __maxsize,
			     __const char *__restrict __format,
			     __const struct tm *__restrict __tp)
  __attribute__ ((__nothrow__, __leaf__));

#215 "/usr/include/time.h" 3 4
#1 "/usr/include/xlocale.h" 1 3 4
#28 "/usr/include/xlocale.h" 3 4
     typedef struct __locale_struct
     {

       struct __locale_data *__locales[13];


       const unsigned short int *__ctype_b;
       const int *__ctype_tolower;
       const int *__ctype_toupper;


       const char *__names[13];
     } *__locale_t;


     typedef __locale_t locale_t;
#216 "/usr/include/time.h" 2 3 4

     extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
			       __const char *__restrict __format,
			       __const struct tm *__restrict __tp,
			       __locale_t __loc)
  __attribute__ ((__nothrow__, __leaf__));
#230 "/usr/include/time.h" 3 4



     extern struct tm *gmtime (__const time_t * __timer)
  __attribute__ ((__nothrow__, __leaf__));



     extern struct tm *localtime (__const time_t * __timer)
  __attribute__ ((__nothrow__, __leaf__));





     extern struct tm *gmtime_r (__const time_t * __restrict __timer,
				 struct tm *__restrict __tp)
  __attribute__ ((__nothrow__, __leaf__));



     extern struct tm *localtime_r (__const time_t * __restrict __timer,
				    struct tm *__restrict __tp)
  __attribute__ ((__nothrow__, __leaf__));





     extern char *asctime (__const struct tm *__tp)
  __attribute__ ((__nothrow__, __leaf__));


     extern char *ctime (__const time_t * __timer)
  __attribute__ ((__nothrow__, __leaf__));







     extern char *asctime_r (__const struct tm *__restrict __tp,
			     char *__restrict __buf)
  __attribute__ ((__nothrow__, __leaf__));


     extern char *ctime_r (__const time_t * __restrict __timer,
			   char *__restrict __buf)
  __attribute__ ((__nothrow__, __leaf__));




     extern char *__tzname[2];
     extern int __daylight;
     extern long int __timezone;




     extern char *tzname[2];



     extern void tzset (void) __attribute__ ((__nothrow__, __leaf__));



     extern int daylight;
     extern long int timezone;





     extern int stime (__const time_t * __when)
  __attribute__ ((__nothrow__, __leaf__));
#313 "/usr/include/time.h" 3 4
     extern time_t timegm (struct tm *__tp)
  __attribute__ ((__nothrow__, __leaf__));


     extern time_t timelocal (struct tm *__tp)
  __attribute__ ((__nothrow__, __leaf__));


     extern int dysize (int __year) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__const__));
#328 "/usr/include/time.h" 3 4
     extern int nanosleep (__const struct timespec *__requested_time,
			   struct timespec *__remaining);



     extern int clock_getres (clockid_t __clock_id, struct timespec *__res)
  __attribute__ ((__nothrow__, __leaf__));


     extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp)
  __attribute__ ((__nothrow__, __leaf__));


     extern int clock_settime (clockid_t __clock_id,
			       __const struct timespec *__tp)
  __attribute__ ((__nothrow__, __leaf__));






     extern int clock_nanosleep (clockid_t __clock_id, int __flags,
				 __const struct timespec *__req,
				 struct timespec *__rem);


     extern int clock_getcpuclockid (pid_t __pid, clockid_t * __clock_id)
  __attribute__ ((__nothrow__, __leaf__));




     extern int timer_create (clockid_t __clock_id,
			      struct sigevent *__restrict __evp,
			      timer_t * __restrict __timerid)
  __attribute__ ((__nothrow__, __leaf__));


     extern int timer_delete (timer_t __timerid)
  __attribute__ ((__nothrow__, __leaf__));


     extern int timer_settime (timer_t __timerid, int __flags,
			       __const struct itimerspec *__restrict __value,
			       struct itimerspec *__restrict __ovalue)
  __attribute__ ((__nothrow__, __leaf__));


     extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
  __attribute__ ((__nothrow__, __leaf__));


     extern int timer_getoverrun (timer_t __timerid)
  __attribute__ ((__nothrow__, __leaf__));
#417 "/usr/include/time.h" 3 4

#1456 "malloc_.c" 2


#1 "/usr/include/stdlib.h" 1 3 4
#33 "/usr/include/stdlib.h" 3 4
#1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
#324 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3 4
     typedef int wchar_t;
#34 "/usr/include/stdlib.h" 2 3 4








#1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
#43 "/usr/include/stdlib.h" 2 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
#67 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
     union wait
     {
       int w_status;
       struct
       {

	 unsigned int __w_termsig:7;
	 unsigned int __w_coredump:1;
	 unsigned int __w_retcode:8;
	 unsigned int:16;







       } __wait_terminated;
       struct
       {

	 unsigned int __w_stopval:8;
	 unsigned int __w_stopsig:8;
	 unsigned int:16;






       } __wait_stopped;
     };
#44 "/usr/include/stdlib.h" 2 3 4
#68 "/usr/include/stdlib.h" 3 4
     typedef union
     {
       union wait *__uptr;
       int *__iptr;
     } __WAIT_STATUS __attribute__ ((__transparent_union__));
#96 "/usr/include/stdlib.h" 3 4


     typedef struct
     {
       int quot;
       int rem;
     } div_t;



     typedef struct
     {
       long int quot;
       long int rem;
     } ldiv_t;







     __extension__ typedef struct
     {
       long long int quot;
       long long int rem;
     } lldiv_t;


#140 "/usr/include/stdlib.h" 3 4
     extern size_t __ctype_get_mb_cur_max (void)
  __attribute__ ((__nothrow__, __leaf__));




     extern double atof (__const char *__nptr)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));

     extern int atoi (__const char *__nptr)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));

     extern long int atol (__const char *__nptr)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));





     __extension__ extern long long int atoll (__const char *__nptr)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));





     extern double strtod (__const char *__restrict __nptr,
			   char **__restrict __endptr)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));





     extern float strtof (__const char *__restrict __nptr,
			  char **__restrict __endptr)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));

     extern long double strtold (__const char *__restrict __nptr,
				 char **__restrict __endptr)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));





     extern long int strtol (__const char *__restrict __nptr,
			     char **__restrict __endptr, int __base)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));

     extern unsigned long int strtoul (__const char *__restrict __nptr,
				       char **__restrict __endptr, int __base)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));




     __extension__
       extern long long int strtoq (__const char *__restrict __nptr,
				    char **__restrict __endptr, int __base)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));

     __extension__
       extern unsigned long long int strtouq (__const char *__restrict __nptr,
					      char **__restrict __endptr,
					      int __base)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));





     __extension__
       extern long long int strtoll (__const char *__restrict __nptr,
				     char **__restrict __endptr, int __base)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));

     __extension__
       extern unsigned long long int strtoull (__const char *__restrict
					       __nptr,
					       char **__restrict __endptr,
					       int __base)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));

#311 "/usr/include/stdlib.h" 3 4
     extern char *l64a (long int __n) __attribute__ ((__nothrow__, __leaf__));


     extern long int a64l (__const char *__s)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));
#327 "/usr/include/stdlib.h" 3 4
     extern long int random (void) __attribute__ ((__nothrow__, __leaf__));


     extern void srandom (unsigned int __seed)
  __attribute__ ((__nothrow__, __leaf__));





     extern char *initstate (unsigned int __seed, char *__statebuf,
			     size_t __statelen)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (2)));



     extern char *setstate (char *__statebuf)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));







     struct random_data
     {
       int32_t *fptr;
       int32_t *rptr;
       int32_t *state;
       int rand_type;
       int rand_deg;
       int rand_sep;
       int32_t *end_ptr;
     };

     extern int random_r (struct random_data *__restrict __buf,
			  int32_t * __restrict __result)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));

     extern int srandom_r (unsigned int __seed, struct random_data *__buf)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (2)));

     extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
			     size_t __statelen,
			     struct random_data *__restrict __buf)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (2, 4)));

     extern int setstate_r (char *__restrict __statebuf,
			    struct random_data *__restrict __buf)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));






     extern int rand (void) __attribute__ ((__nothrow__, __leaf__));

     extern void srand (unsigned int __seed)
  __attribute__ ((__nothrow__, __leaf__));




     extern int rand_r (unsigned int *__seed)
  __attribute__ ((__nothrow__, __leaf__));







     extern double drand48 (void) __attribute__ ((__nothrow__, __leaf__));
     extern double erand48 (unsigned short int __xsubi[3])
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));


     extern long int lrand48 (void) __attribute__ ((__nothrow__, __leaf__));
     extern long int nrand48 (unsigned short int __xsubi[3])
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));


     extern long int mrand48 (void) __attribute__ ((__nothrow__, __leaf__));
     extern long int jrand48 (unsigned short int __xsubi[3])
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));


     extern void srand48 (long int __seedval)
  __attribute__ ((__nothrow__, __leaf__));
     extern unsigned short int *seed48 (unsigned short int __seed16v[3])
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));
     extern void lcong48 (unsigned short int __param[7])
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));





     struct drand48_data
     {
       unsigned short int __x[3];
       unsigned short int __old_x[3];
       unsigned short int __c;
       unsigned short int __init;
       unsigned long long int __a;
     };


     extern int drand48_r (struct drand48_data *__restrict __buffer,
			   double *__restrict __result)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));
     extern int erand48_r (unsigned short int __xsubi[3],
			   struct drand48_data *__restrict __buffer,
			   double *__restrict __result)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));


     extern int lrand48_r (struct drand48_data *__restrict __buffer,
			   long int *__restrict __result)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));
     extern int nrand48_r (unsigned short int __xsubi[3],
			   struct drand48_data *__restrict __buffer,
			   long int *__restrict __result)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));


     extern int mrand48_r (struct drand48_data *__restrict __buffer,
			   long int *__restrict __result)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));
     extern int jrand48_r (unsigned short int __xsubi[3],
			   struct drand48_data *__restrict __buffer,
			   long int *__restrict __result)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));


     extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (2)));

     extern int seed48_r (unsigned short int __seed16v[3],
			  struct drand48_data *__buffer)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));

     extern int lcong48_r (unsigned short int __param[7],
			   struct drand48_data *__buffer)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));









     extern void *malloc (size_t __size)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__malloc__));

     extern void *calloc (size_t __nmemb, size_t __size)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__malloc__));










     extern void *realloc (void *__ptr, size_t __size)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__warn_unused_result__));

     extern void free (void *__ptr) __attribute__ ((__nothrow__, __leaf__));




     extern void cfree (void *__ptr) __attribute__ ((__nothrow__, __leaf__));



#1 "/usr/include/alloca.h" 1 3 4
#25 "/usr/include/alloca.h" 3 4
#1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
#26 "/usr/include/alloca.h" 2 3 4







     extern void *alloca (size_t __size)
  __attribute__ ((__nothrow__, __leaf__));






#498 "/usr/include/stdlib.h" 2 3 4





     extern void *valloc (size_t __size)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__malloc__));




     extern int posix_memalign (void **__memptr, size_t __alignment,
				size_t __size)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));




     extern void abort (void) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__noreturn__));



     extern int atexit (void (*__func) (void))
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));
#531 "/usr/include/stdlib.h" 3 4





     extern int on_exit (void (*__func) (int __status, void *__arg),
			 void *__arg) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1)));






     extern void exit (int __status) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__noreturn__));
#554 "/usr/include/stdlib.h" 3 4






     extern void _Exit (int __status) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__noreturn__));






     extern char *getenv (__const char *__name)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));




     extern char *__secure_getenv (__const char *__name)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));





     extern int putenv (char *__string)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));





     extern int setenv (__const char *__name, __const char *__value,
			int __replace) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (2)));


     extern int unsetenv (__const char *__name)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));






     extern int clearenv (void) __attribute__ ((__nothrow__, __leaf__));
#606 "/usr/include/stdlib.h" 3 4
     extern char *mktemp (char *__template)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));
#620 "/usr/include/stdlib.h" 3 4
     extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1)));
#642 "/usr/include/stdlib.h" 3 4
     extern int mkstemps (char *__template, int __suffixlen)
  __attribute__ ((__nonnull__ (1)));
#663 "/usr/include/stdlib.h" 3 4
     extern char *mkdtemp (char *__template)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));
#712 "/usr/include/stdlib.h" 3 4





     extern int system (__const char *__command);

#734 "/usr/include/stdlib.h" 3 4
     extern char *realpath (__const char *__restrict __name,
			    char *__restrict __resolved)
  __attribute__ ((__nothrow__, __leaf__));






     typedef int (*__compar_fn_t) (__const void *, __const void *);
#752 "/usr/include/stdlib.h" 3 4



     extern void *bsearch (__const void *__key, __const void *__base,
			   size_t __nmemb, size_t __size,
			   __compar_fn_t __compar)
  __attribute__ ((__nonnull__ (1, 2, 5)));



     extern void qsort (void *__base, size_t __nmemb, size_t __size,
			__compar_fn_t __compar)
  __attribute__ ((__nonnull__ (1, 4)));
#771 "/usr/include/stdlib.h" 3 4
     extern int abs (int __x) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__const__));
     extern long int labs (long int __x)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));



     __extension__ extern long long int llabs (long long int __x)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));







     extern div_t div (int __numer, int __denom)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));
     extern ldiv_t ldiv (long int __numer, long int __denom)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));




     __extension__ extern lldiv_t lldiv (long long int __numer,
					 long long int __denom)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));

#808 "/usr/include/stdlib.h" 3 4
     extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
			int *__restrict __sign)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (3, 4)));




     extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
			int *__restrict __sign)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (3, 4)));




     extern char *gcvt (double __value, int __ndigit, char *__buf)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (3)));




     extern char *qecvt (long double __value, int __ndigit,
			 int *__restrict __decpt, int *__restrict __sign)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (3, 4)));
     extern char *qfcvt (long double __value, int __ndigit,
			 int *__restrict __decpt, int *__restrict __sign)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (3, 4)));
     extern char *qgcvt (long double __value, int __ndigit, char *__buf)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (3)));




     extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
			int *__restrict __sign, char *__restrict __buf,
			size_t __len) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (3, 4, 5)));
     extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
			int *__restrict __sign, char *__restrict __buf,
			size_t __len) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (3, 4, 5)));

     extern int qecvt_r (long double __value, int __ndigit,
			 int *__restrict __decpt, int *__restrict __sign,
			 char *__restrict __buf, size_t __len)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (3, 4, 5)));
     extern int qfcvt_r (long double __value, int __ndigit,
			 int *__restrict __decpt, int *__restrict __sign,
			 char *__restrict __buf, size_t __len)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (3, 4, 5)));







     extern int mblen (__const char *__s, size_t __n)
  __attribute__ ((__nothrow__, __leaf__));


     extern int mbtowc (wchar_t * __restrict __pwc,
			__const char *__restrict __s, size_t __n)
  __attribute__ ((__nothrow__, __leaf__));


     extern int wctomb (char *__s, wchar_t __wchar)
  __attribute__ ((__nothrow__, __leaf__));



     extern size_t mbstowcs (wchar_t * __restrict __pwcs,
			     __const char *__restrict __s, size_t __n)
  __attribute__ ((__nothrow__, __leaf__));

     extern size_t wcstombs (char *__restrict __s,
			     __const wchar_t * __restrict __pwcs, size_t __n)
  __attribute__ ((__nothrow__, __leaf__));








     extern int rpmatch (__const char *__response)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));
#896 "/usr/include/stdlib.h" 3 4
     extern int getsubopt (char **__restrict __optionp,
			   char *__const * __restrict __tokens,
			   char **__restrict __valuep)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2, 3)));
#948 "/usr/include/stdlib.h" 3 4
     extern int getloadavg (double __loadavg[], int __nelem)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));
#964 "/usr/include/stdlib.h" 3 4

#1459 "malloc_.c" 2


#1 "/usr/include/string.h" 1 3 4
#29 "/usr/include/string.h" 3 4





#1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
#35 "/usr/include/string.h" 2 3 4









     extern void *memcpy (void *__restrict __dest,
			  __const void *__restrict __src, size_t __n)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));


     extern void *memmove (void *__dest, __const void *__src, size_t __n)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));






     extern void *memccpy (void *__restrict __dest,
			   __const void *__restrict __src, int __c,
			   size_t __n) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));





     extern void *memset (void *__s, int __c, size_t __n)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));


     extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2)));
#95 "/usr/include/string.h" 3 4
     extern void *memchr (__const void *__s, int __c, size_t __n)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));


#126 "/usr/include/string.h" 3 4


     extern char *strcpy (char *__restrict __dest,
			  __const char *__restrict __src)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));

     extern char *strncpy (char *__restrict __dest,
			   __const char *__restrict __src, size_t __n)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));


     extern char *strcat (char *__restrict __dest,
			  __const char *__restrict __src)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));

     extern char *strncat (char *__restrict __dest,
			   __const char *__restrict __src, size_t __n)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));


     extern int strcmp (__const char *__s1, __const char *__s2)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2)));

     extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2)));


     extern int strcoll (__const char *__s1, __const char *__s2)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2)));

     extern size_t strxfrm (char *__restrict __dest,
			    __const char *__restrict __src, size_t __n)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (2)));

#165 "/usr/include/string.h" 3 4
     extern int strcoll_l (__const char *__s1, __const char *__s2,
			   __locale_t __l)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2, 3)));

     extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
			      __locale_t __l)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (2, 4)));





     extern char *strdup (__const char *__s)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__malloc__))
  __attribute__ ((__nonnull__ (1)));






     extern char *strndup (__const char *__string, size_t __n)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__malloc__))
  __attribute__ ((__nonnull__ (1)));
#210 "/usr/include/string.h" 3 4

#235 "/usr/include/string.h" 3 4
     extern char *strchr (__const char *__s, int __c)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));
#262 "/usr/include/string.h" 3 4
     extern char *strrchr (__const char *__s, int __c)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));


#281 "/usr/include/string.h" 3 4



     extern size_t strcspn (__const char *__s, __const char *__reject)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2)));


     extern size_t strspn (__const char *__s, __const char *__accept)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2)));
#314 "/usr/include/string.h" 3 4
     extern char *strpbrk (__const char *__s, __const char *__accept)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2)));
#342 "/usr/include/string.h" 3 4
     extern char *strstr (__const char *__haystack, __const char *__needle)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2)));




     extern char *strtok (char *__restrict __s,
			  __const char *__restrict __delim)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (2)));




     extern char *__strtok_r (char *__restrict __s,
			      __const char *__restrict __delim,
			      char **__restrict __save_ptr)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (2, 3)));

     extern char *strtok_r (char *__restrict __s,
			    __const char *__restrict __delim,
			    char **__restrict __save_ptr)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (2, 3)));
#397 "/usr/include/string.h" 3 4


     extern size_t strlen (__const char *__s)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));





     extern size_t strnlen (__const char *__string, size_t __maxlen)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));





     extern char *strerror (int __errnum)
  __attribute__ ((__nothrow__, __leaf__));

#427 "/usr/include/string.h" 3 4
     extern int strerror_r (int __errnum, char *__buf,
			    size_t __buflen) __asm__ ("" "__xpg_strerror_r")
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (2)));
#445 "/usr/include/string.h" 3 4
     extern char *strerror_l (int __errnum, __locale_t __l)
  __attribute__ ((__nothrow__, __leaf__));





     extern void __bzero (void *__s, size_t __n)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));



     extern void bcopy (__const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));


     extern void bzero (void *__s, size_t __n)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));


     extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2)));
#489 "/usr/include/string.h" 3 4
     extern char *index (__const char *__s, int __c)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));
#517 "/usr/include/string.h" 3 4
     extern char *rindex (__const char *__s, int __c)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1)));




     extern int ffs (int __i) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__const__));
#536 "/usr/include/string.h" 3 4
     extern int strcasecmp (__const char *__s1, __const char *__s2)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2)));


     extern int strncasecmp (__const char *__s1, __const char *__s2,
			     size_t __n)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__pure__))
  __attribute__ ((__nonnull__ (1, 2)));
#559 "/usr/include/string.h" 3 4
     extern char *strsep (char **__restrict __stringp,
			  __const char *__restrict __delim)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));




     extern char *strsignal (int __sig)
  __attribute__ ((__nothrow__, __leaf__));


     extern char *__stpcpy (char *__restrict __dest,
			    __const char *__restrict __src)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));
     extern char *stpcpy (char *__restrict __dest,
			  __const char *__restrict __src)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));



     extern char *__stpncpy (char *__restrict __dest,
			     __const char *__restrict __src, size_t __n)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));
     extern char *stpncpy (char *__restrict __dest,
			   __const char *__restrict __src, size_t __n)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));
#646 "/usr/include/string.h" 3 4

#1462 "malloc_.c" 2
#1473 "malloc_.c"
#1 "/usr/include/x86_64-linux-gnu/sys/mman.h" 1 3 4
#26 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
#1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
#27 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4
#42 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/mman.h" 1 3 4
#43 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4





#58 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
     extern void *mmap (void *__addr, size_t __len, int __prot,
			int __flags, int __fd, __off_t __offset)
  __attribute__ ((__nothrow__, __leaf__));
#77 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
     extern int munmap (void *__addr, size_t __len)
  __attribute__ ((__nothrow__, __leaf__));




     extern int mprotect (void *__addr, size_t __len, int __prot)
  __attribute__ ((__nothrow__, __leaf__));







     extern int msync (void *__addr, size_t __len, int __flags);




     extern int madvise (void *__addr, size_t __len, int __advice)
  __attribute__ ((__nothrow__, __leaf__));



     extern int posix_madvise (void *__addr, size_t __len, int __advice)
  __attribute__ ((__nothrow__, __leaf__));




     extern int mlock (__const void *__addr, size_t __len)
  __attribute__ ((__nothrow__, __leaf__));


     extern int munlock (__const void *__addr, size_t __len)
  __attribute__ ((__nothrow__, __leaf__));




     extern int mlockall (int __flags)
  __attribute__ ((__nothrow__, __leaf__));



     extern int munlockall (void) __attribute__ ((__nothrow__, __leaf__));







     extern int mincore (void *__start, size_t __len, unsigned char *__vec)
  __attribute__ ((__nothrow__, __leaf__));
#134 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
     extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
			  int __flags, ...)
  __attribute__ ((__nothrow__, __leaf__));



     extern int remap_file_pages (void *__start, size_t __size, int __prot,
				  size_t __pgoff, int __flags)
  __attribute__ ((__nothrow__, __leaf__));




     extern int shm_open (__const char *__name, int __oflag, mode_t __mode);


     extern int shm_unlink (__const char *__name);


#1474 "malloc_.c" 2






#1 "/usr/include/fcntl.h" 1 3 4
#30 "/usr/include/fcntl.h" 3 4




#1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
#26 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#27 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
#168 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
     struct flock
     {
       short int l_type;
       short int l_whence;

       __off_t l_start;
       __off_t l_len;




       __pid_t l_pid;
     };
#282 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4

#356 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4

#35 "/usr/include/fcntl.h" 2 3 4






#1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
#46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
     struct stat
     {
       __dev_t st_dev;




       __ino_t st_ino;







       __nlink_t st_nlink;
       __mode_t st_mode;

       __uid_t st_uid;
       __gid_t st_gid;

       int __pad0;

       __dev_t st_rdev;




       __off_t st_size;



       __blksize_t st_blksize;

       __blkcnt_t st_blocks;
#91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
       struct timespec st_atim;
       struct timespec st_mtim;
       struct timespec st_ctim;
#106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
       long int __unused[3];
#115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
     };
#42 "/usr/include/fcntl.h" 2 3 4
#110 "/usr/include/fcntl.h" 3 4
     extern int fcntl (int __fd, int __cmd, ...);
#119 "/usr/include/fcntl.h" 3 4
     extern int open (__const char *__file, int __oflag, ...)
  __attribute__ ((__nonnull__ (1)));
#143 "/usr/include/fcntl.h" 3 4
     extern int openat (int __fd, __const char *__file, int __oflag, ...)
  __attribute__ ((__nonnull__ (2)));
#165 "/usr/include/fcntl.h" 3 4
     extern int creat (__const char *__file, __mode_t __mode)
  __attribute__ ((__nonnull__ (1)));
#194 "/usr/include/fcntl.h" 3 4
     extern int lockf (int __fd, int __cmd, __off_t __len);
#211 "/usr/include/fcntl.h" 3 4
     extern int posix_fadvise (int __fd, __off_t __offset, __off_t __len,
			       int __advise)
  __attribute__ ((__nothrow__, __leaf__));
#233 "/usr/include/fcntl.h" 3 4
     extern int posix_fallocate (int __fd, __off_t __offset, __off_t __len);
#255 "/usr/include/fcntl.h" 3 4

#1481 "malloc_.c" 2



#1 "/usr/include/unistd.h" 1 3 4
#28 "/usr/include/unistd.h" 3 4

#203 "/usr/include/unistd.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
#204 "/usr/include/unistd.h" 2 3 4



#1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
#23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#24 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
#208 "/usr/include/unistd.h" 2 3 4
#227 "/usr/include/unistd.h" 3 4
#1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
#228 "/usr/include/unistd.h" 2 3 4
#256 "/usr/include/unistd.h" 3 4
     typedef __useconds_t useconds_t;
#268 "/usr/include/unistd.h" 3 4
     typedef __intptr_t intptr_t;






     typedef __socklen_t socklen_t;
#288 "/usr/include/unistd.h" 3 4
     extern int access (__const char *__name, int __type)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));
#305 "/usr/include/unistd.h" 3 4
     extern int faccessat (int __fd, __const char *__file, int __type,
			   int __flag) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (2)));
#335 "/usr/include/unistd.h" 3 4
     extern __off_t lseek (int __fd, __off_t __offset, int __whence)
  __attribute__ ((__nothrow__, __leaf__));
#354 "/usr/include/unistd.h" 3 4
     extern int close (int __fd);






     extern ssize_t read (int __fd, void *__buf, size_t __nbytes);





     extern ssize_t write (int __fd, __const void *__buf, size_t __n);
#377 "/usr/include/unistd.h" 3 4
     extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
			   __off_t __offset);






     extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
			    __off_t __offset);
#418 "/usr/include/unistd.h" 3 4
     extern int pipe (int __pipedes[2])
  __attribute__ ((__nothrow__, __leaf__));
#433 "/usr/include/unistd.h" 3 4
     extern unsigned int alarm (unsigned int __seconds)
  __attribute__ ((__nothrow__, __leaf__));
#445 "/usr/include/unistd.h" 3 4
     extern unsigned int sleep (unsigned int __seconds);







     extern __useconds_t ualarm (__useconds_t __value,
				 __useconds_t __interval)
  __attribute__ ((__nothrow__, __leaf__));






     extern int usleep (__useconds_t __useconds);
#470 "/usr/include/unistd.h" 3 4
     extern int pause (void);



     extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));



     extern int fchown (int __fd, __uid_t __owner, __gid_t __group)
  __attribute__ ((__nothrow__, __leaf__));




     extern int lchown (__const char *__file, __uid_t __owner,
			__gid_t __group)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));






     extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
			  __gid_t __group, int __flag)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (2)));



     extern int chdir (__const char *__path)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));



     extern int fchdir (int __fd) __attribute__ ((__nothrow__, __leaf__));
#512 "/usr/include/unistd.h" 3 4
     extern char *getcwd (char *__buf, size_t __size)
  __attribute__ ((__nothrow__, __leaf__));
#526 "/usr/include/unistd.h" 3 4
     extern char *getwd (char *__buf)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__deprecated__));




     extern int dup (int __fd) __attribute__ ((__nothrow__, __leaf__));


     extern int dup2 (int __fd, int __fd2)
  __attribute__ ((__nothrow__, __leaf__));
#544 "/usr/include/unistd.h" 3 4
     extern char **__environ;







     extern int execve (__const char *__path, char *__const __argv[],
			char *__const __envp[])
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));




     extern int fexecve (int __fd, char *__const __argv[],
			 char *__const __envp[])
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (2)));




     extern int execv (__const char *__path, char *__const __argv[])
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));



     extern int execle (__const char *__path, __const char *__arg, ...)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));



     extern int execl (__const char *__path, __const char *__arg, ...)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));



     extern int execvp (__const char *__file, char *__const __argv[])
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));




     extern int execlp (__const char *__file, __const char *__arg, ...)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));
#599 "/usr/include/unistd.h" 3 4
     extern int nice (int __inc) __attribute__ ((__nothrow__, __leaf__));




     extern void _exit (int __status) __attribute__ ((__noreturn__));





#1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
#26 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
     enum
     {
       _PC_LINK_MAX,

       _PC_MAX_CANON,

       _PC_MAX_INPUT,

       _PC_NAME_MAX,

       _PC_PATH_MAX,

       _PC_PIPE_BUF,

       _PC_CHOWN_RESTRICTED,

       _PC_NO_TRUNC,

       _PC_VDISABLE,

       _PC_SYNC_IO,

       _PC_ASYNC_IO,

       _PC_PRIO_IO,

       _PC_SOCK_MAXBUF,

       _PC_FILESIZEBITS,

       _PC_REC_INCR_XFER_SIZE,

       _PC_REC_MAX_XFER_SIZE,

       _PC_REC_MIN_XFER_SIZE,

       _PC_REC_XFER_ALIGN,

       _PC_ALLOC_SIZE_MIN,

       _PC_SYMLINK_MAX,

       _PC_2_SYMLINKS
     };


     enum
     {
       _SC_ARG_MAX,

       _SC_CHILD_MAX,

       _SC_CLK_TCK,

       _SC_NGROUPS_MAX,

       _SC_OPEN_MAX,

       _SC_STREAM_MAX,

       _SC_TZNAME_MAX,

       _SC_JOB_CONTROL,

       _SC_SAVED_IDS,

       _SC_REALTIME_SIGNALS,

       _SC_PRIORITY_SCHEDULING,

       _SC_TIMERS,

       _SC_ASYNCHRONOUS_IO,

       _SC_PRIORITIZED_IO,

       _SC_SYNCHRONIZED_IO,

       _SC_FSYNC,

       _SC_MAPPED_FILES,

       _SC_MEMLOCK,

       _SC_MEMLOCK_RANGE,

       _SC_MEMORY_PROTECTION,

       _SC_MESSAGE_PASSING,

       _SC_SEMAPHORES,

       _SC_SHARED_MEMORY_OBJECTS,

       _SC_AIO_LISTIO_MAX,

       _SC_AIO_MAX,

       _SC_AIO_PRIO_DELTA_MAX,

       _SC_DELAYTIMER_MAX,

       _SC_MQ_OPEN_MAX,

       _SC_MQ_PRIO_MAX,

       _SC_VERSION,

       _SC_PAGESIZE,


       _SC_RTSIG_MAX,

       _SC_SEM_NSEMS_MAX,

       _SC_SEM_VALUE_MAX,

       _SC_SIGQUEUE_MAX,

       _SC_TIMER_MAX,




       _SC_BC_BASE_MAX,

       _SC_BC_DIM_MAX,

       _SC_BC_SCALE_MAX,

       _SC_BC_STRING_MAX,

       _SC_COLL_WEIGHTS_MAX,

       _SC_EQUIV_CLASS_MAX,

       _SC_EXPR_NEST_MAX,

       _SC_LINE_MAX,

       _SC_RE_DUP_MAX,

       _SC_CHARCLASS_NAME_MAX,


       _SC_2_VERSION,

       _SC_2_C_BIND,

       _SC_2_C_DEV,

       _SC_2_FORT_DEV,

       _SC_2_FORT_RUN,

       _SC_2_SW_DEV,

       _SC_2_LOCALEDEF,


       _SC_PII,

       _SC_PII_XTI,

       _SC_PII_SOCKET,

       _SC_PII_INTERNET,

       _SC_PII_OSI,

       _SC_POLL,

       _SC_SELECT,

       _SC_UIO_MAXIOV,

       _SC_IOV_MAX = _SC_UIO_MAXIOV,

       _SC_PII_INTERNET_STREAM,

       _SC_PII_INTERNET_DGRAM,

       _SC_PII_OSI_COTS,

       _SC_PII_OSI_CLTS,

       _SC_PII_OSI_M,

       _SC_T_IOV_MAX,



       _SC_THREADS,

       _SC_THREAD_SAFE_FUNCTIONS,

       _SC_GETGR_R_SIZE_MAX,

       _SC_GETPW_R_SIZE_MAX,

       _SC_LOGIN_NAME_MAX,

       _SC_TTY_NAME_MAX,

       _SC_THREAD_DESTRUCTOR_ITERATIONS,

       _SC_THREAD_KEYS_MAX,

       _SC_THREAD_STACK_MIN,

       _SC_THREAD_THREADS_MAX,

       _SC_THREAD_ATTR_STACKADDR,

       _SC_THREAD_ATTR_STACKSIZE,

       _SC_THREAD_PRIORITY_SCHEDULING,

       _SC_THREAD_PRIO_INHERIT,

       _SC_THREAD_PRIO_PROTECT,

       _SC_THREAD_PROCESS_SHARED,


       _SC_NPROCESSORS_CONF,

       _SC_NPROCESSORS_ONLN,

       _SC_PHYS_PAGES,

       _SC_AVPHYS_PAGES,

       _SC_ATEXIT_MAX,

       _SC_PASS_MAX,


       _SC_XOPEN_VERSION,

       _SC_XOPEN_XCU_VERSION,

       _SC_XOPEN_UNIX,

       _SC_XOPEN_CRYPT,

       _SC_XOPEN_ENH_I18N,

       _SC_XOPEN_SHM,


       _SC_2_CHAR_TERM,

       _SC_2_C_VERSION,

       _SC_2_UPE,


       _SC_XOPEN_XPG2,

       _SC_XOPEN_XPG3,

       _SC_XOPEN_XPG4,


       _SC_CHAR_BIT,

       _SC_CHAR_MAX,

       _SC_CHAR_MIN,

       _SC_INT_MAX,

       _SC_INT_MIN,

       _SC_LONG_BIT,

       _SC_WORD_BIT,

       _SC_MB_LEN_MAX,

       _SC_NZERO,

       _SC_SSIZE_MAX,

       _SC_SCHAR_MAX,

       _SC_SCHAR_MIN,

       _SC_SHRT_MAX,

       _SC_SHRT_MIN,

       _SC_UCHAR_MAX,

       _SC_UINT_MAX,

       _SC_ULONG_MAX,

       _SC_USHRT_MAX,


       _SC_NL_ARGMAX,

       _SC_NL_LANGMAX,

       _SC_NL_MSGMAX,

       _SC_NL_NMAX,

       _SC_NL_SETMAX,

       _SC_NL_TEXTMAX,


       _SC_XBS5_ILP32_OFF32,

       _SC_XBS5_ILP32_OFFBIG,

       _SC_XBS5_LP64_OFF64,

       _SC_XBS5_LPBIG_OFFBIG,


       _SC_XOPEN_LEGACY,

       _SC_XOPEN_REALTIME,

       _SC_XOPEN_REALTIME_THREADS,


       _SC_ADVISORY_INFO,

       _SC_BARRIERS,

       _SC_BASE,

       _SC_C_LANG_SUPPORT,

       _SC_C_LANG_SUPPORT_R,

       _SC_CLOCK_SELECTION,

       _SC_CPUTIME,

       _SC_THREAD_CPUTIME,

       _SC_DEVICE_IO,

       _SC_DEVICE_SPECIFIC,

       _SC_DEVICE_SPECIFIC_R,

       _SC_FD_MGMT,

       _SC_FIFO,

       _SC_PIPE,

       _SC_FILE_ATTRIBUTES,

       _SC_FILE_LOCKING,

       _SC_FILE_SYSTEM,

       _SC_MONOTONIC_CLOCK,

       _SC_MULTI_PROCESS,

       _SC_SINGLE_PROCESS,

       _SC_NETWORKING,

       _SC_READER_WRITER_LOCKS,

       _SC_SPIN_LOCKS,

       _SC_REGEXP,

       _SC_REGEX_VERSION,

       _SC_SHELL,

       _SC_SIGNALS,

       _SC_SPAWN,

       _SC_SPORADIC_SERVER,

       _SC_THREAD_SPORADIC_SERVER,

       _SC_SYSTEM_DATABASE,

       _SC_SYSTEM_DATABASE_R,

       _SC_TIMEOUTS,

       _SC_TYPED_MEMORY_OBJECTS,

       _SC_USER_GROUPS,

       _SC_USER_GROUPS_R,

       _SC_2_PBS,

       _SC_2_PBS_ACCOUNTING,

       _SC_2_PBS_LOCATE,

       _SC_2_PBS_MESSAGE,

       _SC_2_PBS_TRACK,

       _SC_SYMLOOP_MAX,

       _SC_STREAMS,

       _SC_2_PBS_CHECKPOINT,


       _SC_V6_ILP32_OFF32,

       _SC_V6_ILP32_OFFBIG,

       _SC_V6_LP64_OFF64,

       _SC_V6_LPBIG_OFFBIG,


       _SC_HOST_NAME_MAX,

       _SC_TRACE,

       _SC_TRACE_EVENT_FILTER,

       _SC_TRACE_INHERIT,

       _SC_TRACE_LOG,


       _SC_LEVEL1_ICACHE_SIZE,

       _SC_LEVEL1_ICACHE_ASSOC,

       _SC_LEVEL1_ICACHE_LINESIZE,

       _SC_LEVEL1_DCACHE_SIZE,

       _SC_LEVEL1_DCACHE_ASSOC,

       _SC_LEVEL1_DCACHE_LINESIZE,

       _SC_LEVEL2_CACHE_SIZE,

       _SC_LEVEL2_CACHE_ASSOC,

       _SC_LEVEL2_CACHE_LINESIZE,

       _SC_LEVEL3_CACHE_SIZE,

       _SC_LEVEL3_CACHE_ASSOC,

       _SC_LEVEL3_CACHE_LINESIZE,

       _SC_LEVEL4_CACHE_SIZE,

       _SC_LEVEL4_CACHE_ASSOC,

       _SC_LEVEL4_CACHE_LINESIZE,



       _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

       _SC_RAW_SOCKETS,


       _SC_V7_ILP32_OFF32,

       _SC_V7_ILP32_OFFBIG,

       _SC_V7_LP64_OFF64,

       _SC_V7_LPBIG_OFFBIG,


       _SC_SS_REPL_MAX,


       _SC_TRACE_EVENT_NAME_MAX,

       _SC_TRACE_NAME_MAX,

       _SC_TRACE_SYS_MAX,

       _SC_TRACE_USER_EVENT_MAX,


       _SC_XOPEN_STREAMS,


       _SC_THREAD_ROBUST_PRIO_INHERIT,

       _SC_THREAD_ROBUST_PRIO_PROTECT
     };


     enum
     {
       _CS_PATH,


       _CS_V6_WIDTH_RESTRICTED_ENVS,



       _CS_GNU_LIBC_VERSION,

       _CS_GNU_LIBPTHREAD_VERSION,


       _CS_V5_WIDTH_RESTRICTED_ENVS,



       _CS_V7_WIDTH_RESTRICTED_ENVS,



       _CS_LFS_CFLAGS = 1000,

       _CS_LFS_LDFLAGS,

       _CS_LFS_LIBS,

       _CS_LFS_LINTFLAGS,

       _CS_LFS64_CFLAGS,

       _CS_LFS64_LDFLAGS,

       _CS_LFS64_LIBS,

       _CS_LFS64_LINTFLAGS,


       _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

       _CS_XBS5_ILP32_OFF32_LDFLAGS,

       _CS_XBS5_ILP32_OFF32_LIBS,

       _CS_XBS5_ILP32_OFF32_LINTFLAGS,

       _CS_XBS5_ILP32_OFFBIG_CFLAGS,

       _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

       _CS_XBS5_ILP32_OFFBIG_LIBS,

       _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

       _CS_XBS5_LP64_OFF64_CFLAGS,

       _CS_XBS5_LP64_OFF64_LDFLAGS,

       _CS_XBS5_LP64_OFF64_LIBS,

       _CS_XBS5_LP64_OFF64_LINTFLAGS,

       _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

       _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

       _CS_XBS5_LPBIG_OFFBIG_LIBS,

       _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


       _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

       _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

       _CS_POSIX_V6_ILP32_OFF32_LIBS,

       _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

       _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

       _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

       _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

       _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

       _CS_POSIX_V6_LP64_OFF64_CFLAGS,

       _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

       _CS_POSIX_V6_LP64_OFF64_LIBS,

       _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

       _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

       _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

       _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

       _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


       _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

       _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

       _CS_POSIX_V7_ILP32_OFF32_LIBS,

       _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

       _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

       _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

       _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

       _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

       _CS_POSIX_V7_LP64_OFF64_CFLAGS,

       _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

       _CS_POSIX_V7_LP64_OFF64_LIBS,

       _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

       _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

       _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

       _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

       _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


       _CS_V6_ENV,

       _CS_V7_ENV
     };
#611 "/usr/include/unistd.h" 2 3 4


     extern long int pathconf (__const char *__path, int __name)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));


     extern long int fpathconf (int __fd, int __name)
  __attribute__ ((__nothrow__, __leaf__));


     extern long int sysconf (int __name)
  __attribute__ ((__nothrow__, __leaf__));



     extern size_t confstr (int __name, char *__buf, size_t __len)
  __attribute__ ((__nothrow__, __leaf__));




     extern __pid_t getpid (void) __attribute__ ((__nothrow__, __leaf__));


     extern __pid_t getppid (void) __attribute__ ((__nothrow__, __leaf__));




     extern __pid_t getpgrp (void) __attribute__ ((__nothrow__, __leaf__));
#647 "/usr/include/unistd.h" 3 4
     extern __pid_t __getpgid (__pid_t __pid)
  __attribute__ ((__nothrow__, __leaf__));

     extern __pid_t getpgid (__pid_t __pid)
  __attribute__ ((__nothrow__, __leaf__));






     extern int setpgid (__pid_t __pid, __pid_t __pgid)
  __attribute__ ((__nothrow__, __leaf__));
#673 "/usr/include/unistd.h" 3 4
     extern int setpgrp (void) __attribute__ ((__nothrow__, __leaf__));
#690 "/usr/include/unistd.h" 3 4
     extern __pid_t setsid (void) __attribute__ ((__nothrow__, __leaf__));



     extern __pid_t getsid (__pid_t __pid)
  __attribute__ ((__nothrow__, __leaf__));



     extern __uid_t getuid (void) __attribute__ ((__nothrow__, __leaf__));


     extern __uid_t geteuid (void) __attribute__ ((__nothrow__, __leaf__));


     extern __gid_t getgid (void) __attribute__ ((__nothrow__, __leaf__));


     extern __gid_t getegid (void) __attribute__ ((__nothrow__, __leaf__));




     extern int getgroups (int __size, __gid_t __list[])
  __attribute__ ((__nothrow__, __leaf__));
#723 "/usr/include/unistd.h" 3 4
     extern int setuid (__uid_t __uid)
  __attribute__ ((__nothrow__, __leaf__));




     extern int setreuid (__uid_t __ruid, __uid_t __euid)
  __attribute__ ((__nothrow__, __leaf__));




     extern int seteuid (__uid_t __uid)
  __attribute__ ((__nothrow__, __leaf__));






     extern int setgid (__gid_t __gid)
  __attribute__ ((__nothrow__, __leaf__));




     extern int setregid (__gid_t __rgid, __gid_t __egid)
  __attribute__ ((__nothrow__, __leaf__));




     extern int setegid (__gid_t __gid)
  __attribute__ ((__nothrow__, __leaf__));
#779 "/usr/include/unistd.h" 3 4
     extern __pid_t fork (void) __attribute__ ((__nothrow__));







     extern __pid_t vfork (void) __attribute__ ((__nothrow__, __leaf__));





     extern char *ttyname (int __fd) __attribute__ ((__nothrow__, __leaf__));



     extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (2)));



     extern int isatty (int __fd) __attribute__ ((__nothrow__, __leaf__));





     extern int ttyslot (void) __attribute__ ((__nothrow__, __leaf__));




     extern int link (__const char *__from, __const char *__to)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));




     extern int linkat (int __fromfd, __const char *__from, int __tofd,
			__const char *__to, int __flags)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (2, 4)));




     extern int symlink (__const char *__from, __const char *__to)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));




     extern ssize_t readlink (__const char *__restrict __path,
			      char *__restrict __buf, size_t __len)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 2)));




     extern int symlinkat (__const char *__from, int __tofd,
			   __const char *__to)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (1, 3)));


     extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
				char *__restrict __buf, size_t __len)
  __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__nonnull__ (2, 3)));



     extern int unlink (__const char *__name)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));



     extern int unlinkat (int __fd, __const char *__name, int __flag)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (2)));



     extern int rmdir (__const char *__path)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));



     extern __pid_t tcgetpgrp (int __fd)
  __attribute__ ((__nothrow__, __leaf__));


     extern int tcsetpgrp (int __fd, __pid_t __pgrp_id)
  __attribute__ ((__nothrow__, __leaf__));






     extern char *getlogin (void);







     extern int getlogin_r (char *__name, size_t __name_len)
  __attribute__ ((__nonnull__ (1)));




     extern int setlogin (__const char *__name)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));
#894 "/usr/include/unistd.h" 3 4
#1 "/usr/include/getopt.h" 1 3 4
#59 "/usr/include/getopt.h" 3 4
     extern char *optarg;
#73 "/usr/include/getopt.h" 3 4
     extern int optind;




     extern int opterr;



     extern int optopt;
#152 "/usr/include/getopt.h" 3 4
     extern int getopt (int ___argc, char *const *___argv,
			const char *__shortopts)
  __attribute__ ((__nothrow__, __leaf__));
#895 "/usr/include/unistd.h" 2 3 4







     extern int gethostname (char *__name, size_t __len)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));






     extern int sethostname (__const char *__name, size_t __len)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));



     extern int sethostid (long int __id)
  __attribute__ ((__nothrow__, __leaf__));





     extern int getdomainname (char *__name, size_t __len)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));
     extern int setdomainname (__const char *__name, size_t __len)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));





     extern int vhangup (void) __attribute__ ((__nothrow__, __leaf__));


     extern int revoke (__const char *__file)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));







     extern int profil (unsigned short int *__sample_buffer, size_t __size,
			size_t __offset, unsigned int __scale)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));





     extern int acct (__const char *__name)
  __attribute__ ((__nothrow__, __leaf__));



     extern char *getusershell (void) __attribute__ ((__nothrow__, __leaf__));
     extern void endusershell (void) __attribute__ ((__nothrow__, __leaf__));
     extern void setusershell (void) __attribute__ ((__nothrow__, __leaf__));





     extern int daemon (int __nochdir, int __noclose)
  __attribute__ ((__nothrow__, __leaf__));






     extern int chroot (__const char *__path)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));



     extern char *getpass (__const char *__prompt)
  __attribute__ ((__nonnull__ (1)));
#980 "/usr/include/unistd.h" 3 4
     extern int fsync (int __fd);
#994 "/usr/include/unistd.h" 3 4
     extern long int gethostid (void);


     extern void sync (void) __attribute__ ((__nothrow__, __leaf__));





     extern int getpagesize (void) __attribute__ ((__nothrow__, __leaf__))
  __attribute__ ((__const__));




     extern int getdtablesize (void) __attribute__ ((__nothrow__, __leaf__));
#1018 "/usr/include/unistd.h" 3 4
     extern int truncate (__const char *__file, __off_t __length)
  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));
#1040 "/usr/include/unistd.h" 3 4
     extern int ftruncate (int __fd, __off_t __length)
  __attribute__ ((__nothrow__, __leaf__));
#1061 "/usr/include/unistd.h" 3 4
     extern int brk (void *__addr) __attribute__ ((__nothrow__, __leaf__));





     extern void *sbrk (intptr_t __delta)
  __attribute__ ((__nothrow__, __leaf__));
#1082 "/usr/include/unistd.h" 3 4
     extern long int syscall (long int __sysno, ...)
  __attribute__ ((__nothrow__, __leaf__));
#1136 "/usr/include/unistd.h" 3 4
     extern int fdatasync (int __fildes);
#1165 "/usr/include/unistd.h" 3 4
     extern char *ctermid (char *__s) __attribute__ ((__nothrow__, __leaf__));
#1174 "/usr/include/unistd.h" 3 4

#1485 "malloc_.c" 2
#2182 "malloc_.c"
     struct malloc_chunk
     {
       size_t prev_foot;
       size_t head;
       struct malloc_chunk *fd;
       struct malloc_chunk *bk;
     };

     typedef struct malloc_chunk mchunk;
     typedef struct malloc_chunk *mchunkptr;
     typedef struct malloc_chunk *sbinptr;
     typedef unsigned int bindex_t;
     typedef unsigned int binmap_t;
     typedef unsigned int flag_t;
#2391 "malloc_.c"
     struct malloc_tree_chunk
     {

       size_t prev_foot;
       size_t head;
       struct malloc_tree_chunk *fd;
       struct malloc_tree_chunk *bk;

       struct malloc_tree_chunk *child[2];
       struct malloc_tree_chunk *parent;
       bindex_t index;
     };

     typedef struct malloc_tree_chunk tchunk;
     typedef struct malloc_tree_chunk *tchunkptr;
     typedef struct malloc_tree_chunk *tbinptr;
#2467 "malloc_.c"
     struct malloc_segment
     {
       char *base;
       size_t size;
       struct malloc_segment *next;
       flag_t sflags;
     };




     typedef struct malloc_segment msegment;
     typedef struct malloc_segment *msegmentptr;
#2577 "malloc_.c"
     struct malloc_state
     {
       binmap_t smallmap;
       binmap_t treemap;
       size_t dvsize;
       size_t topsize;
       char *least_addr;
       mchunkptr dv;
       mchunkptr top;
       size_t trim_check;
       size_t release_checks;
       size_t magic;
       mchunkptr smallbins[((32U) + 1) * 2];
       tbinptr treebins[(32U)];
       size_t footprint;
       size_t max_footprint;
       size_t footprint_limit;
       flag_t mflags;



       msegment seg;
       void *extp;
       size_t exts;
     };

     typedef struct malloc_state *mstate;
#2613 "malloc_.c"
     struct malloc_params
     {
       size_t magic;
       size_t page_size;
       size_t granularity;
       size_t mmap_threshold;
       size_t trim_threshold;
       flag_t default_mflags;
     };

     static struct malloc_params mparams;







     static struct malloc_state _gm_;
#2696 "malloc_.c"
     static msegmentptr segment_holding (mstate m, char *addr)
{
  msegmentptr sp = &m->seg;
  for (;;)
    {
      if (addr >= sp->base && addr < sp->base + sp->size)
	return sp;
      if ((sp = sp->next) == 0)
	return 0;
    }
}


static int
has_segment_link (mstate m, msegmentptr ss)
{
  msegmentptr sp = &m->seg;
  for (;;)
    {
      if ((char *) sp >= ss->base && (char *) sp < ss->base + ss->size)
	return 1;
      if ((sp = sp->next) == 0)
	return 0;
    }
}

#3111 "malloc_.c"
static int
init_mparams (void)
{





  ;
  if (mparams.magic == 0)
    {
      size_t magic;
      size_t psize;
      size_t gsize;


      psize = sysconf (_SC_PAGESIZE);
      gsize = (((0) != 0) ? (0) : psize);
#3142 "malloc_.c"
      if ((sizeof (size_t) != sizeof (char *)) ||
	  ((~(size_t) 0) <
	   (((sizeof (mchunk)) +
	     (((size_t) (2 * sizeof (void *))) -
	      ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				 ((size_t) 1)))) || (sizeof (int) < 4)
	  || (((size_t) (2 * sizeof (void *))) < (size_t) 8U)
	  ||
	  ((((size_t) (2 * sizeof (void *))) &
	    (((size_t) (2 * sizeof (void *))) - ((size_t) 1))) != 0)
	  || (((sizeof (mchunk)) & ((sizeof (mchunk)) - ((size_t) 1))) != 0)
	  || ((gsize & (gsize - ((size_t) 1))) != 0)
	  || ((psize & (psize - ((size_t) 1))) != 0))
	abort ();
      mparams.granularity = gsize;
      mparams.page_size = psize;
      mparams.mmap_threshold = ((size_t) 256U * (size_t) 1024U);
      mparams.trim_threshold =
	((size_t) 2U * (size_t) 1024U * (size_t) 1024U);

      mparams.default_mflags = (0U) | (((size_t) 1));






      (&_gm_)->mflags = mparams.default_mflags;
      (void) (0);





      {
#3187 "malloc_.c"
	magic = (size_t) (time (0) ^ (size_t) 0x55555555U);

	magic |= (size_t) 8U;
	magic &= ~(size_t) 7U;

	(*(volatile size_t *) (&(mparams.magic))) = magic;
      }
    }

  ;
  return 1;
}


static int
change_mparam (int param_number, int value)
{
  size_t val;
  (void) (mparams.magic != 0 || init_mparams ());
  val = (value == -1) ? (~(size_t) 0) : (size_t) value;
  switch (param_number)
    {
    case (-1):
      mparams.trim_threshold = val;
      return 1;
    case (-2):
      if (val >= mparams.page_size && ((val & (val - 1)) == 0))
	{
	  mparams.granularity = val;
	  return 1;
	}
      else
	return 0;
    case (-3):
      mparams.mmap_threshold = val;
      return 1;
    default:
      return 0;
    }
}

#3496 "malloc_.c"
static struct mallinfo
internal_mallinfo (mstate m)
{
  struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  (void) (mparams.magic != 0 || init_mparams ());
  if (!(0))
    {
      ;
      if (((m)->top != 0))
	{
	  size_t nfree = ((size_t) 1);
	  size_t mfree =
	    m->topsize +
	    (((((size_t)
		(((void *) ((char *) (0) +
			    ((sizeof (size_t)) << 1)))) & (((size_t) (2 *
								      sizeof
								      (void
								       *))) -
							   ((size_t) 1))) ==
	       0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
			  ((size_t)
			   (((void *) ((char *) (0) +
				       ((sizeof (size_t)) << 1)))) &
			   (((size_t) (2 * sizeof (void *))) -
			    ((size_t) 1)))) & (((size_t) (2 *
							  sizeof (void *))) -
					       ((size_t) 1)))) +
	     (((sizeof (struct malloc_segment)) + ((sizeof (size_t))) +
	       (((size_t) (2 * sizeof (void *))) -
		((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				   ((size_t) 1))) + (((sizeof (mchunk)) +
						      (((size_t)
							(2 *
							 sizeof (void *))) -
						       ((size_t) 1))) &
						     ~(((size_t)
							(2 *
							 sizeof (void *))) -
						       ((size_t) 1))));
	  size_t sum = mfree;
	  msegmentptr s = &m->seg;
	  while (s != 0)
	    {
	      mchunkptr q =
		(mchunkptr) ((s->base) +
			     ((((size_t)
				(((void *) ((char *) (s->base) +
					    ((sizeof (size_t)) << 1)))) &
				(((size_t) (2 * sizeof (void *))) -
				 ((size_t) 1))) ==
			       0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
					  ((size_t)
					   (((void *) ((char *) (s->base) +
						       ((sizeof (size_t)) <<
							1)))) & (((size_t) (2
									    *
									    sizeof
									    (void
									     *)))
								 -
								 ((size_t)
								  1)))) &
					 (((size_t) (2 * sizeof (void *))) -
					  ((size_t) 1)))));
	      while (((char *) (q) >= s->base
		      && (char *) (q) < s->base + s->size) && q != m->top
		     && q->head !=
		     (((((size_t) 1)) | (((size_t) 2))) | (sizeof (size_t))))
		{
		  size_t sz =
		    ((q)->
		     head &
		     ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));
		  sum += sz;
		  if (!
		      (((q)->head & ((((size_t) 1)) | (((size_t) 2)))) !=
		       (((size_t) 1))))
		    {
		      mfree += sz;
		      ++nfree;
		    }
		  q =
		    ((mchunkptr)
		     (((char *) (q)) +
		      ((q)->
		       head & ~((((size_t) 1)) | (((size_t) 2)) |
				(((size_t) 4))))));
		}
	      s = s->next;
	    }

	  nm.arena = sum;
	  nm.ordblks = nfree;
	  nm.hblkhd = m->footprint - sum;
	  nm.usmblks = m->max_footprint;
	  nm.uordblks = m->footprint - mfree;
	  nm.fordblks = mfree;
	  nm.keepcost = m->topsize;
	}

      ;
    }
  return nm;
}



static void
internal_malloc_stats (mstate m)
{
  (void) (mparams.magic != 0 || init_mparams ());
  if (!(0))
    {
      size_t maxfp = 0;
      size_t fp = 0;
      size_t used = 0;
      ;
      if (((m)->top != 0))
	{
	  msegmentptr s = &m->seg;
	  maxfp = m->max_footprint;
	  fp = m->footprint;
	  used =
	    fp - (m->topsize +
		  (((((size_t)
		      (((void *) ((char *) (0) +
				  ((sizeof (size_t)) << 1)))) & (((size_t) (2
									    *
									    sizeof
									    (void
									     *)))
								 -
								 ((size_t)
								  1))) ==
		     0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
				((size_t)
				 (((void *) ((char *) (0) +
					     ((sizeof (size_t)) << 1)))) &
				 (((size_t) (2 * sizeof (void *))) -
				  ((size_t) 1)))) & (((size_t) (2 *
								sizeof (void
									*))) -
						     ((size_t) 1)))) +
		   (((sizeof (struct malloc_segment)) + ((sizeof (size_t))) +
		     (((size_t) (2 * sizeof (void *))) -
		      ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
					 ((size_t) 1))) +
		   (((sizeof (mchunk)) +
		     (((size_t) (2 * sizeof (void *))) -
		      ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
					 ((size_t) 1)))));

	  while (s != 0)
	    {
	      mchunkptr q =
		(mchunkptr) ((s->base) +
			     ((((size_t)
				(((void *) ((char *) (s->base) +
					    ((sizeof (size_t)) << 1)))) &
				(((size_t) (2 * sizeof (void *))) -
				 ((size_t) 1))) ==
			       0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
					  ((size_t)
					   (((void *) ((char *) (s->base) +
						       ((sizeof (size_t)) <<
							1)))) & (((size_t) (2
									    *
									    sizeof
									    (void
									     *)))
								 -
								 ((size_t)
								  1)))) &
					 (((size_t) (2 * sizeof (void *))) -
					  ((size_t) 1)))));
	      while (((char *) (q) >= s->base
		      && (char *) (q) < s->base + s->size) && q != m->top
		     && q->head !=
		     (((((size_t) 1)) | (((size_t) 2))) | (sizeof (size_t))))
		{
		  if (!
		      (((q)->head & ((((size_t) 1)) | (((size_t) 2)))) !=
		       (((size_t) 1))))
		    used -=
		      ((q)->
		       head &
		       ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));
		  q =
		    ((mchunkptr)
		     (((char *) (q)) +
		      ((q)->
		       head & ~((((size_t) 1)) | (((size_t) 2)) |
				(((size_t) 4))))));
		}
	      s = s->next;
	    }
	}
      ;
      fprintf (stderr, "max system bytes = %10lu\n", (unsigned long) (maxfp));
      fprintf (stderr, "system bytes     = %10lu\n", (unsigned long) (fp));
      fprintf (stderr, "in use bytes     = %10lu\n", (unsigned long) (used));
    }
}

#3835 "malloc_.c"
static void *
mmap_alloc (mstate m, size_t nb)
{
  size_t mmsize =
    (((nb + (((sizeof (size_t)) << 2) + ((sizeof (size_t)) << 1)) +
       (((size_t) (2 * sizeof (void *))) - ((size_t) 1))) +
      (mparams.page_size - ((size_t) 1))) & ~(mparams.page_size -
					      ((size_t) 1)));
  if (m->footprint_limit != 0)
    {
      size_t fp = m->footprint + mmsize;
      if (fp <= m->footprint || fp > m->footprint_limit)
	return 0;
    }
  if (mmsize > nb)
    {
      char *mm =
	(char *) (mmap (0, (mmsize), (0x1 | 0x2), (0x02 | 0x20), -1, 0));
      if (mm != ((char *) (((void *) ((~(size_t) 0))))))
	{

	  fprintf (stderr, "memory: %zd\t%p\n", mmsize, ((void *) 0));
	  size_t offset =
	    ((((size_t)
	       (((void *) ((char *) (mm) +
			   ((sizeof (size_t)) << 1)))) & (((size_t) (2 *
								     sizeof
								     (void
								      *))) -
							  ((size_t) 1))) ==
	      0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
			 ((size_t)
			  (((void *) ((char *) (mm) +
				      ((sizeof (size_t)) << 1)))) &
			  (((size_t) (2 * sizeof (void *))) -
			   ((size_t) 1)))) & (((size_t) (2 *
							 sizeof (void *))) -
					      ((size_t) 1))));
	  size_t psize = mmsize - offset - (((sizeof (size_t)) << 2));
	  mchunkptr p = (mchunkptr) (mm + offset);
	  p->prev_foot = offset;
	  p->head = psize;
	  ;
	  ((mchunkptr) (((char *) (p)) + (psize)))->head =
	    (((((size_t) 1)) | (((size_t) 2))) | (sizeof (size_t)));
	  ((mchunkptr) (((char *) (p)) + (psize + (sizeof (size_t)))))->head =
	    0;

	  if (m->least_addr == 0 || mm < m->least_addr)
	    m->least_addr = mm;
	  if ((m->footprint += mmsize) > m->max_footprint)
	    m->max_footprint = m->footprint;
	  ;
	  ;
	  return ((void *) ((char *) (p) + ((sizeof (size_t)) << 1)));
	}
    }
  return 0;
}


static mchunkptr
mmap_resize (mstate m, mchunkptr oldp, size_t nb, int flags)
{
  size_t oldsize =
    ((oldp)->head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));
  (void) flags;
  if ((((nb) >> (3U)) < (32U)))
    return 0;

  if (oldsize >= nb + (sizeof (size_t)) &&
      (oldsize - nb) <= (mparams.granularity << 1))
    return oldp;
  else
    {
      size_t offset = oldp->prev_foot;
      size_t oldmmsize = oldsize + offset + (((sizeof (size_t)) << 2));
      size_t newmmsize =
	(((nb + (((sizeof (size_t)) << 2) + ((sizeof (size_t)) << 1)) +
	   (((size_t) (2 * sizeof (void *))) - ((size_t) 1))) +
	  (mparams.page_size - ((size_t) 1))) & ~(mparams.page_size -
						  ((size_t) 1)));
      char *cp =
	(char *) mremap ((((char *) oldp - offset)), ((oldmmsize)),
			 ((newmmsize)), ((flags)));
      if (cp != ((char *) (((void *) ((~(size_t) 0))))))
	{
	  mchunkptr newp = (mchunkptr) (cp + offset);
	  size_t psize = newmmsize - offset - (((sizeof (size_t)) << 2));
	  newp->head = psize;
	  ;
	  ((mchunkptr) (((char *) (newp)) + (psize)))->head =
	    (((((size_t) 1)) | (((size_t) 2))) | (sizeof (size_t)));
	  ((mchunkptr) (((char *) (newp)) + (psize + (sizeof (size_t)))))->
	    head = 0;

	  fprintf (stderr, "memory: %zd\t%p\n", newmmsize - oldmmsize,
		   ((void *) 0));

	  if (cp < m->least_addr)
	    m->least_addr = cp;
	  if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)
	    m->max_footprint = m->footprint;
	  ;
	  return newp;
	}
    }
  return 0;
}





static void
init_top (mstate m, mchunkptr p, size_t psize)
{

  size_t offset =
    ((((size_t) (((void *) ((char *) (p) + ((sizeof (size_t)) << 1)))) &
       (((size_t) (2 * sizeof (void *))) - ((size_t) 1))) ==
      0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
		 ((size_t)
		  (((void *) ((char *) (p) +
			      ((sizeof (size_t)) << 1)))) & (((size_t) (2 *
									sizeof
									(void
									 *)))
							     -
							     ((size_t) 1)))) &
		(((size_t) (2 * sizeof (void *))) - ((size_t) 1))));
  p = (mchunkptr) ((char *) p + offset);
  psize -= offset;

  m->top = p;
  m->topsize = psize;
  p->head = psize | (((size_t) 1));

  ((mchunkptr) (((char *) (p)) + (psize)))->head =
    (((((size_t) (((void *) ((char *) (0) + ((sizeof (size_t)) << 1)))) &
	(((size_t) (2 * sizeof (void *))) - ((size_t) 1))) ==
       0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
		  ((size_t)
		   (((void *) ((char *) (0) +
			       ((sizeof (size_t)) << 1)))) & (((size_t) (2 *
									 sizeof
									 (void
									  *)))
							      -
							      ((size_t) 1))))
		 & (((size_t) (2 * sizeof (void *))) - ((size_t) 1)))) +
     (((sizeof (struct malloc_segment)) + ((sizeof (size_t))) +
       (((size_t) (2 * sizeof (void *))) -
	((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) - ((size_t) 1))) +
     (((sizeof (mchunk)) +
       (((size_t) (2 * sizeof (void *))) -
	((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) - ((size_t) 1))));
  m->trim_check = mparams.trim_threshold;
}


static void
init_bins (mstate m)
{

  bindex_t i;
  for (i = 0; i < (32U); ++i)
    {
      sbinptr bin = ((sbinptr) ((char *) &((m)->smallbins[(i) << 1])));
      bin->fd = bin->bk = bin;
    }
}

#3953 "malloc_.c"
static void *
prepend_alloc (mstate m, char *newbase, char *oldbase, size_t nb)
{
  mchunkptr p =
    (mchunkptr) ((newbase) +
		 ((((size_t)
		    (((void *) ((char *) (newbase) +
				((sizeof (size_t)) << 1)))) & (((size_t) (2 *
									  sizeof
									  (void
									   *)))
							       -
							       ((size_t) 1)))
		   ==
		   0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
			      ((size_t)
			       (((void *) ((char *) (newbase) +
					   ((sizeof (size_t)) << 1)))) &
			       (((size_t) (2 * sizeof (void *))) -
				((size_t) 1)))) & (((size_t) (2 *
							      sizeof (void
								      *))) -
						   ((size_t) 1)))));
  mchunkptr oldfirst =
    (mchunkptr) ((oldbase) +
		 ((((size_t)
		    (((void *) ((char *) (oldbase) +
				((sizeof (size_t)) << 1)))) & (((size_t) (2 *
									  sizeof
									  (void
									   *)))
							       -
							       ((size_t) 1)))
		   ==
		   0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
			      ((size_t)
			       (((void *) ((char *) (oldbase) +
					   ((sizeof (size_t)) << 1)))) &
			       (((size_t) (2 * sizeof (void *))) -
				((size_t) 1)))) & (((size_t) (2 *
							      sizeof (void
								      *))) -
						   ((size_t) 1)))));
  size_t psize = (char *) oldfirst - (char *) p;
  mchunkptr q = ((mchunkptr) (((char *) (p)) + (nb)));
  size_t qsize = psize - nb;
  ((p)->head = (nb | (((size_t) 1)) | (((size_t) 2))));

  ;
  ;
  ;


  if (oldfirst == m->top)
    {
      size_t tsize = m->topsize += qsize;
      m->top = q;
      q->head = tsize | (((size_t) 1));
      ;
    }
  else if (oldfirst == m->dv)
    {
      size_t dsize = m->dvsize += qsize;
      m->dv = q;
      ((q)->head =
       (dsize | (((size_t) 1))),
       (((mchunkptr) ((char *) (q) + (dsize)))->prev_foot = (dsize)));
    }
  else
    {
      if (!
	  (((oldfirst)->head & ((((size_t) 1)) | (((size_t) 2)))) !=
	   (((size_t) 1))))
	{
	  size_t nsize =
	    ((oldfirst)->
	     head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));
	  if ((((nsize) >> (3U)) < (32U)))
	    {
	      mchunkptr F = oldfirst->fd;
	      mchunkptr B = oldfirst->bk;
	      bindex_t I = (bindex_t) ((nsize) >> (3U));;;;
	      if (__builtin_expect
		  (F == ((sbinptr) ((char *) &((m)->smallbins[(I) << 1])))
		   || (((char *) (F) >= (m)->least_addr)
		       && F->bk == oldfirst), 1))
		{
		  if (B == F)
		    {
		      ((m)->smallmap &= ~((binmap_t) (1) << (I)));
		    }
		  else
		    if (__builtin_expect
			(B ==
			 ((sbinptr) ((char *) &((m)->smallbins[(I) << 1])))
			 || (((char *) (B) >= (m)->least_addr)
			     && B->fd == oldfirst), 1))
		    {
		      F->bk = B;
		      B->fd = F;
		    }
		  else
		    {
		      abort ();
		    }
		}
	      else
		{
		  abort ();
		}
	    }
	  else
	    {
	      tchunkptr TP = (tchunkptr) (oldfirst);
	      {
		tchunkptr XP = TP->parent;
		tchunkptr R;
		if (TP->bk != TP)
		  {
		    tchunkptr F = TP->fd;
		    R = TP->bk;
		    if (__builtin_expect
			(((char *) (F) >= (m)->least_addr) && F->bk == TP
			 && R->fd == TP, 1))
		      {
			F->bk = R;
			R->fd = F;
		      }
		    else
		      {
			abort ();
		      }
		  }
		else
		  {
		    tchunkptr *RP;
		    if (((R = *(RP = &(TP->child[1]))) != 0)
			|| ((R = *(RP = &(TP->child[0]))) != 0))
		      {
			tchunkptr *CP;
			while ((*(CP = &(R->child[1])) != 0)
			       || (*(CP = &(R->child[0])) != 0))
			  {
			    R = *(RP = CP);
			  }
			if (__builtin_expect
			    (((char *) (RP) >= (m)->least_addr), 1))
			  *RP = 0;
			else
			  {
			    abort ();
			  }
		      }
		  }
		if (XP != 0)
		  {
		    tbinptr *H = (&((m)->treebins[TP->index]));
		    if (TP == *H)
		      {
			if ((*H = R) == 0)
			  ((m)->treemap &= ~((binmap_t) (1) << (TP->index)));
		      }
		    else
		      if (__builtin_expect
			  (((char *) (XP) >= (m)->least_addr), 1))
		      {
			if (XP->child[0] == TP)
			  XP->child[0] = R;
			else
			  XP->child[1] = R;
		      }
		    else
		      abort ();
		    if (R != 0)
		      {
			if (__builtin_expect
			    (((char *) (R) >= (m)->least_addr), 1))
			  {
			    tchunkptr C0, C1;
			    R->parent = XP;
			    if ((C0 = TP->child[0]) != 0)
			      {
				if (__builtin_expect
				    (((char *) (C0) >= (m)->least_addr), 1))
				  {
				    R->child[0] = C0;
				    C0->parent = R;
				  }
				else
				  abort ();
			      }
			    if ((C1 = TP->child[1]) != 0)
			      {
				if (__builtin_expect
				    (((char *) (C1) >= (m)->least_addr), 1))
				  {
				    R->child[1] = C1;
				    C1->parent = R;
				  }
				else
				  abort ();
			      }
			  }
			else
			  abort ();
		      }
		  }
	      };
	    };
	  oldfirst = ((mchunkptr) (((char *) (oldfirst)) + (nsize)));
	  qsize += nsize;
	}
      (((oldfirst)->head &= ~(((size_t) 1))), ((q)->head =
					       (qsize | (((size_t) 1))),
					       (((mchunkptr)
						 ((char *) (q) +
						  (qsize)))->prev_foot =
						(qsize))));
      if ((((qsize) >> (3U)) < (32U)))
	{
	  bindex_t I = (bindex_t) ((qsize) >> (3U));
	  mchunkptr B = ((sbinptr) ((char *) &((m)->smallbins[(I) << 1])));
	  mchunkptr F = B;;
	  if (!((m)->smallmap & ((binmap_t) (1) << (I))))
	    ((m)->smallmap |= ((binmap_t) (1) << (I)));
	  else
	    if (__builtin_expect (((char *) (B->fd) >= (m)->least_addr), 1))
	    F = B->fd;
	  else
	    {
	      abort ();
	    }
	  B->fd = q;
	  F->bk = q;
	  q->fd = F;
	  q->bk = B;
	}
      else
	{
	  tchunkptr TP = (tchunkptr) (q);
	  {
	    tbinptr *H;
	    bindex_t I;
	    {
	      unsigned int X = qsize >> (8U);
	      if (X == 0)
		I = 0;
	      else if (X > 0xFFFF)
		I = (32U) - 1;
	      else
		{
		  unsigned int K =
		    (unsigned) sizeof (X) * 8 - 1 -
		    (unsigned) __builtin_clz (X);
		  I =
		    (bindex_t) ((K << 1) + ((qsize >> (K + ((8U) - 1)) & 1)));
	    }};
	    H = (&((m)->treebins[I]));
	    TP->index = I;
	    TP->child[0] = TP->child[1] = 0;
	    if (!((m)->treemap & ((binmap_t) (1) << (I))))
	      {
		((m)->treemap |= ((binmap_t) (1) << (I)));
		*H = TP;
		TP->parent = (tchunkptr) H;
		TP->fd = TP->bk = TP;
	      }
	    else
	      {
		tchunkptr T = *H;
		size_t K =
		  qsize << ((I == (32U) - 1) ? 0
			    : (((sizeof (size_t) << 3) - ((size_t) 1)) -
			       (((I) >> 1) + (8U) - 2)));
		for (;;)
		  {
		    if (((T)->
			 head &
			 ~(((((size_t) 1)) | (((size_t) 2)) |
			    (((size_t) 4))))) != qsize)
		      {
			tchunkptr *C =
			  &(T->
			    child[(K >>
				   ((sizeof (size_t) << 3) -
				    ((size_t) 1))) & 1]);
			K <<= 1;
			if (*C != 0)
			  T = *C;
			else
			  if (__builtin_expect
			      (((char *) (C) >= (m)->least_addr), 1))
			  {
			    *C = TP;
			    TP->parent = T;
			    TP->fd = TP->bk = TP;
			    break;
			  }
			else
			  {
			    abort ();
			    break;
			  }
		      }
		    else
		      {
			tchunkptr F = T->fd;
			if (__builtin_expect
			    (((char *) (T) >= (m)->least_addr)
			     && ((char *) (F) >= (m)->least_addr), 1))
			  {
			    T->fd = F->bk = TP;
			    TP->fd = F;
			    TP->bk = T;
			    TP->parent = 0;
			    break;
			  }
			else
			  {
			    abort ();
			    break;
			  }
		      }
		  }
	      }
	  };
	};
      ;
    }

  ;
  return ((void *) ((char *) (p) + ((sizeof (size_t)) << 1)));
}


static void
add_segment (mstate m, char *tbase, size_t tsize, flag_t mmapped)
{

  char *old_top = (char *) m->top;
  msegmentptr oldsp = segment_holding (m, old_top);
  char *old_end = oldsp->base + oldsp->size;
  size_t ssize =
    (((sizeof (struct malloc_segment)) + ((sizeof (size_t))) +
      (((size_t) (2 * sizeof (void *))) -
       ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) - ((size_t) 1)));
  char *rawsp =
    old_end - (ssize + ((sizeof (size_t)) << 2) +
	       (((size_t) (2 * sizeof (void *))) - ((size_t) 1)));
  size_t offset =
    ((((size_t) (((void *) ((char *) (rawsp) + ((sizeof (size_t)) << 1)))) &
       (((size_t) (2 * sizeof (void *))) - ((size_t) 1))) ==
      0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
		 ((size_t)
		  (((void *) ((char *) (rawsp) +
			      ((sizeof (size_t)) << 1)))) & (((size_t) (2 *
									sizeof
									(void
									 *)))
							     -
							     ((size_t) 1)))) &
		(((size_t) (2 * sizeof (void *))) - ((size_t) 1))));
  char *asp = rawsp + offset;
  char *csp =
    (asp <
     (old_top +
      (((sizeof (mchunk)) +
	(((size_t) (2 * sizeof (void *))) -
	 ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
			    ((size_t) 1))))) ? old_top : asp;
  mchunkptr sp = (mchunkptr) csp;
  msegmentptr ss =
    (msegmentptr) (((void *) ((char *) (sp) + ((sizeof (size_t)) << 1))));
  mchunkptr tnext = ((mchunkptr) (((char *) (sp)) + (ssize)));
  mchunkptr p = tnext;
  int nfences = 0;


  init_top (m, (mchunkptr) tbase,
	    tsize -
	    (((((size_t)
		(((void *) ((char *) (0) +
			    ((sizeof (size_t)) << 1)))) & (((size_t) (2 *
								      sizeof
								      (void
								       *))) -
							   ((size_t) 1))) ==
	       0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
			  ((size_t)
			   (((void *) ((char *) (0) +
				       ((sizeof (size_t)) << 1)))) &
			   (((size_t) (2 * sizeof (void *))) -
			    ((size_t) 1)))) & (((size_t) (2 *
							  sizeof (void *))) -
					       ((size_t) 1)))) +
	     (((sizeof (struct malloc_segment)) + ((sizeof (size_t))) +
	       (((size_t) (2 * sizeof (void *))) -
		((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				   ((size_t) 1))) + (((sizeof (mchunk)) +
						      (((size_t)
							(2 *
							 sizeof (void *))) -
						       ((size_t) 1))) &
						     ~(((size_t)
							(2 *
							 sizeof (void *))) -
						       ((size_t) 1)))));


  ;
  ((sp)->head = (ssize | (((size_t) 1)) | (((size_t) 2))));
  *ss = m->seg;
  m->seg.base = tbase;
  m->seg.size = tsize;
  m->seg.sflags = mmapped;
  m->seg.next = ss;


  for (;;)
    {
      mchunkptr nextp = ((mchunkptr) (((char *) (p)) + ((sizeof (size_t)))));
      p->head = (((((size_t) 1)) | (((size_t) 2))) | (sizeof (size_t)));
      ++nfences;
      if ((char *) (&(nextp->head)) < old_end)
	p = nextp;
      else
	break;
    }
  ;


  if (csp != old_top)
    {
      mchunkptr q = (mchunkptr) old_top;
      size_t psize = csp - old_top;
      mchunkptr tn = ((mchunkptr) (((char *) (q)) + (psize)));
      (((tn)->head &= ~(((size_t) 1))), ((q)->head =
					 (psize | (((size_t) 1))),
					 (((mchunkptr)
					   ((char *) (q) +
					    (psize)))->prev_foot = (psize))));
      if ((((psize) >> (3U)) < (32U)))
	{
	  bindex_t I = (bindex_t) ((psize) >> (3U));
	  mchunkptr B = ((sbinptr) ((char *) &((m)->smallbins[(I) << 1])));
	  mchunkptr F = B;;
	  if (!((m)->smallmap & ((binmap_t) (1) << (I))))
	    ((m)->smallmap |= ((binmap_t) (1) << (I)));
	  else
	    if (__builtin_expect (((char *) (B->fd) >= (m)->least_addr), 1))
	    F = B->fd;
	  else
	    {
	      abort ();
	    }
	  B->fd = q;
	  F->bk = q;
	  q->fd = F;
	  q->bk = B;
	}
      else
	{
	  tchunkptr TP = (tchunkptr) (q);
	  {
	    tbinptr *H;
	    bindex_t I;
	    {
	      unsigned int X = psize >> (8U);
	      if (X == 0)
		I = 0;
	      else if (X > 0xFFFF)
		I = (32U) - 1;
	      else
		{
		  unsigned int K =
		    (unsigned) sizeof (X) * 8 - 1 -
		    (unsigned) __builtin_clz (X);
		  I =
		    (bindex_t) ((K << 1) + ((psize >> (K + ((8U) - 1)) & 1)));
	    }};
	    H = (&((m)->treebins[I]));
	    TP->index = I;
	    TP->child[0] = TP->child[1] = 0;
	    if (!((m)->treemap & ((binmap_t) (1) << (I))))
	      {
		((m)->treemap |= ((binmap_t) (1) << (I)));
		*H = TP;
		TP->parent = (tchunkptr) H;
		TP->fd = TP->bk = TP;
	      }
	    else
	      {
		tchunkptr T = *H;
		size_t K =
		  psize << ((I == (32U) - 1) ? 0
			    : (((sizeof (size_t) << 3) - ((size_t) 1)) -
			       (((I) >> 1) + (8U) - 2)));
		for (;;)
		  {
		    if (((T)->
			 head &
			 ~(((((size_t) 1)) | (((size_t) 2)) |
			    (((size_t) 4))))) != psize)
		      {
			tchunkptr *C =
			  &(T->
			    child[(K >>
				   ((sizeof (size_t) << 3) -
				    ((size_t) 1))) & 1]);
			K <<= 1;
			if (*C != 0)
			  T = *C;
			else
			  if (__builtin_expect
			      (((char *) (C) >= (m)->least_addr), 1))
			  {
			    *C = TP;
			    TP->parent = T;
			    TP->fd = TP->bk = TP;
			    break;
			  }
			else
			  {
			    abort ();
			    break;
			  }
		      }
		    else
		      {
			tchunkptr F = T->fd;
			if (__builtin_expect
			    (((char *) (T) >= (m)->least_addr)
			     && ((char *) (F) >= (m)->least_addr), 1))
			  {
			    T->fd = F->bk = TP;
			    TP->fd = F;
			    TP->bk = T;
			    TP->parent = 0;
			    break;
			  }
			else
			  {
			    abort ();
			    break;
			  }
		      }
		  }
	      }
	  };
	};
    }

  ;
}





static void *
sys_alloc (mstate m, size_t nb)
{
  char *tbase = ((char *) (((void *) ((~(size_t) 0)))));
  size_t tsize = 0;
  flag_t mmap_flag = 0;
  size_t asize;
  (void) (mparams.magic != 0 || init_mparams ());
  if (((m)->mflags & (((size_t) 1))) && nb >= mparams.mmap_threshold
      && m->topsize != 0)
    {
      void *mem = mmap_alloc (m, nb);
      if (mem != 0)
	return mem;

    }

  asize =
    (((nb +
       ((((((size_t) (((void *) ((char *) (0) + ((sizeof (size_t)) << 1)))) &
	    (((size_t) (2 * sizeof (void *))) - ((size_t) 1))) ==
	   0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
		      ((size_t)
		       (((void *) ((char *) (0) +
				   ((sizeof (size_t)) << 1)))) & (((size_t) (2
									     *
									     sizeof
									     (void
									      *)))
								  -
								  ((size_t)
								   1)))) &
		     (((size_t) (2 * sizeof (void *))) - ((size_t) 1)))) +
	 (((sizeof (struct malloc_segment)) + ((sizeof (size_t))) +
	   (((size_t) (2 * sizeof (void *))) -
	    ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
			       ((size_t) 1))) + (((sizeof (mchunk)) +
						  (((size_t)
						    (2 * sizeof (void *))) -
						   ((size_t) 1))) &
						 ~(((size_t)
						    (2 * sizeof (void *))) -
						   ((size_t) 1)))) +
	((size_t) (2 * sizeof (void *))))) + (mparams.granularity -
					      ((size_t) 1))) & ~(mparams.
								 granularity -
								 ((size_t)
								  1)));
  if (asize <= nb)
    return 0;

  if (m->footprint_limit != 0)
    {
      size_t fp = m->footprint + asize;
      if (fp <= m->footprint || fp > m->footprint_limit)
	return 0;

    }

  if (1 && !((m)->mflags & (4U)))
    {
      char *br = ((char *) (((void *) ((~(size_t) 0)))));
      size_t ssize = asize;
      msegmentptr ss =
	(m->top == 0) ? 0 : segment_holding (m, (char *) m->top);
      ;
      if (ss == 0)
	{
	  char *base = (char *) sbrk (0);
	  fprintf (stderr, "start: %p\n", base);
	  if (base != ((char *) (((void *) ((~(size_t) 0))))))
	    {
	      size_t fp;
	      if (!
		  (((size_t) (base) & (mparams.page_size - ((size_t) 1))) ==
		   0))
		ssize +=
		  (((((size_t) base) +
		     (mparams.page_size -
		      ((size_t) 1))) & ~(mparams.page_size - ((size_t) 1))) -
		   (size_t) base);

	      fp = m->footprint + ssize;
	      if (ssize > nb && ssize < ((~(size_t) 0) / 2U)
		  && (m->footprint_limit == 0
		      || (fp > m->footprint && fp <= m->footprint_limit))
		  && (br = (char *) (sbrk (ssize))) == base)
		{
		  tbase = base;
		  tsize = ssize;
		  fprintf (stderr, "memory: %zd\t%p\n", ssize, sbrk (0));
		}

	    }

	}
      else
	{
	  ssize =
	    (((nb - m->topsize +
	       ((((((size_t)
		    (((void *) ((char *) (0) +
				((sizeof (size_t)) << 1)))) & (((size_t) (2 *
									  sizeof
									  (void
									   *)))
							       -
							       ((size_t) 1)))
		   ==
		   0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
			      ((size_t)
			       (((void *) ((char *) (0) +
					   ((sizeof (size_t)) << 1)))) &
			       (((size_t) (2 * sizeof (void *))) -
				((size_t) 1)))) & (((size_t) (2 *
							      sizeof (void
								      *))) -
						   ((size_t) 1)))) +
		 (((sizeof (struct malloc_segment)) + ((sizeof (size_t))) +
		   (((size_t) (2 * sizeof (void *))) -
		    ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				       ((size_t) 1))) + (((sizeof (mchunk)) +
							  (((size_t)
							    (2 *
							     sizeof (void *)))
							   -
							   ((size_t) 1))) &
							 ~(((size_t)
							    (2 *
							     sizeof (void *)))
							   - ((size_t) 1)))) +
		((size_t) (2 * sizeof (void *))))) + (mparams.granularity -
						      ((size_t) 1))) &
	     ~(mparams.granularity - ((size_t) 1)));
	  if (ssize < ((~(size_t) 0) / 2U)
	      && (br = (char *) (sbrk (ssize))) == ss->base + ss->size)
	    {
	      tbase = br;
	      tsize = ssize;
	      fprintf (stderr, "memory: %zd\t%p\n", ssize, sbrk (0));
	    }

	}

      if (tbase == ((char *) (((void *) ((~(size_t) 0))))))
	{
	  if (br != ((char *) (((void *) ((~(size_t) 0))))))
	    {
	      if (ssize < ((~(size_t) 0) / 2U)
		  && ssize <
		  nb +
		  ((((((size_t)
		       (((void *) ((char *) (0) +
				   ((sizeof (size_t)) << 1)))) & (((size_t) (2
									     *
									     sizeof
									     (void
									      *)))
								  -
								  ((size_t)
								   1))) ==
		      0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
				 ((size_t)
				  (((void *) ((char *) (0) +
					      ((sizeof (size_t)) << 1)))) &
				  (((size_t) (2 * sizeof (void *))) -
				   ((size_t) 1)))) & (((size_t) (2 *
								 sizeof (void
									 *)))
						      - ((size_t) 1)))) +
		    (((sizeof (struct malloc_segment)) + ((sizeof (size_t))) +
		      (((size_t) (2 * sizeof (void *))) -
		       ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
					  ((size_t) 1))) +
		    (((sizeof (mchunk)) +
		      (((size_t) (2 * sizeof (void *))) -
		       ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
					  ((size_t) 1)))) +
		   ((size_t) (2 * sizeof (void *)))))
		{
		  size_t esize =
		    (((nb +
		       ((((((size_t)
			    (((void *) ((char *) (0) +
					((sizeof (size_t)) << 1)))) &
			    (((size_t) (2 * sizeof (void *))) -
			     ((size_t) 1))) ==
			   0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
				      ((size_t)
				       (((void *) ((char *) (0) +
						   ((sizeof (size_t)) << 1))))
				       & (((size_t) (2 * sizeof (void *))) -
					  ((size_t) 1)))) & (((size_t) (2 *
									sizeof
									(void
									 *)))
							     -
							     ((size_t) 1)))) +
			 (((sizeof (struct malloc_segment)) +
			   ((sizeof (size_t))) +
			   (((size_t) (2 * sizeof (void *))) -
			    ((size_t) 1))) & ~(((size_t) (2 *
							  sizeof (void *))) -
					       ((size_t) 1))) +
			 (((sizeof (mchunk)) +
			   (((size_t) (2 * sizeof (void *))) -
			    ((size_t) 1))) & ~(((size_t) (2 *
							  sizeof (void *))) -
					       ((size_t) 1)))) +
			((size_t) (2 * sizeof (void *)))) - ssize) +
		      (mparams.granularity -
		       ((size_t) 1))) & ~(mparams.granularity -
					  ((size_t) 1)));
		  if (esize < ((~(size_t) 0) / 2U))
		    {
		      char *end = (char *) sbrk (esize);
		      if (end != ((char *) (((void *) ((~(size_t) 0))))))
			{
			  ssize += esize;
			  fprintf (stderr, "memory: %zd\t%p\n", esize,
				   sbrk (0));
			}
		      else
			{
			  (void) sbrk (-ssize);
			  br = ((char *) (((void *) ((~(size_t) 0)))));
			  fprintf (stderr, "memory: %zd\t%p\n", -ssize,
				   sbrk (0));
			}

		    }

		}

	    }

	  if (br != ((char *) (((void *) ((~(size_t) 0))))))
	    {
	      tbase = br;
	      tsize = ssize;
	    }
	  else
	    ((m)->mflags |= (4U));

	}

      ;
    }

  if (1 && tbase == ((char *) (((void *) ((~(size_t) 0))))))
    {
      char *mp =
	(char *) (mmap (0, (asize), (0x1 | 0x2), (0x02 | 0x20), -1, 0));
      if (mp != ((char *) (((void *) ((~(size_t) 0))))))
	{
	  tbase = mp;
	  tsize = asize;
	  mmap_flag = (((size_t) 1));
	  fprintf (stderr, "memory: %zd\t%p\n", asize, ((void *) 0));
	}

    }

  if (1 && tbase == ((char *) (((void *) ((~(size_t) 0))))))
    {
      if (asize < ((~(size_t) 0) / 2U))
	{
	  char *br = ((char *) (((void *) ((~(size_t) 0)))));
	  char *end = ((char *) (((void *) ((~(size_t) 0)))));
	  ;
	  br = (char *) (sbrk (asize));
	  ;
	  end = (char *) (sbrk (0));
	  ;
	  ;
	  if (br != ((char *) (((void *) ((~(size_t) 0)))))
	      && end != ((char *) (((void *) ((~(size_t) 0))))) && br < end)
	    {
	      size_t ssize = end - br;
	      if (ssize >
		  nb +
		  (((((size_t)
		      (((void *) ((char *) (0) +
				  ((sizeof (size_t)) << 1)))) & (((size_t) (2
									    *
									    sizeof
									    (void
									     *)))
								 -
								 ((size_t)
								  1))) ==
		     0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
				((size_t)
				 (((void *) ((char *) (0) +
					     ((sizeof (size_t)) << 1)))) &
				 (((size_t) (2 * sizeof (void *))) -
				  ((size_t) 1)))) & (((size_t) (2 *
								sizeof (void
									*))) -
						     ((size_t) 1)))) +
		   (((sizeof (struct malloc_segment)) + ((sizeof (size_t))) +
		     (((size_t) (2 * sizeof (void *))) -
		      ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
					 ((size_t) 1))) +
		   (((sizeof (mchunk)) +
		     (((size_t) (2 * sizeof (void *))) -
		      ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
					 ((size_t) 1)))))
		{
		  tbase = br;
		  tsize = ssize;
		  fprintf (stderr, "memory: %zd\t%p\n", ssize, sbrk (0));
		}

	    }

	}

    }

  if (tbase != ((char *) (((void *) ((~(size_t) 0))))))
    {
      if ((m->footprint += tsize) > m->max_footprint)
	m->max_footprint = m->footprint;

      if (!((m)->top != 0))
	{
	  if (m->least_addr == 0 || tbase < m->least_addr)
	    m->least_addr = tbase;

	  m->seg.base = tbase;
	  m->seg.size = tsize;
	  m->seg.sflags = mmap_flag;
	  m->magic = mparams.magic;
	  m->release_checks = 4095;
	  init_bins (m);
	  if (((m) == &_gm_))
	    init_top (m, (mchunkptr) tbase,
		      tsize -
		      (((((size_t)
			  (((void *) ((char *) (0) +
				      ((sizeof (size_t)) << 1)))) &
			  (((size_t) (2 * sizeof (void *))) -
			   ((size_t) 1))) ==
			 0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
				    ((size_t)
				     (((void *) ((char *) (0) +
						 ((sizeof (size_t)) << 1)))) &
				     (((size_t) (2 * sizeof (void *))) -
				      ((size_t) 1)))) & (((size_t) (2 *
								    sizeof
								    (void *)))
							 - ((size_t) 1)))) +
		       (((sizeof (struct malloc_segment)) +
			 ((sizeof (size_t))) +
			 (((size_t) (2 * sizeof (void *))) -
			  ((size_t) 1))) & ~(((size_t) (2 *
							sizeof (void *))) -
					     ((size_t) 1))) +
		       (((sizeof (mchunk)) +
			 (((size_t) (2 * sizeof (void *))) -
			  ((size_t) 1))) & ~(((size_t) (2 *
							sizeof (void *))) -
					     ((size_t) 1)))));
	  else
	    {
	      mchunkptr mn =
		((mchunkptr)
		 (((char
		    *) (((mchunkptr)
			 ((char *) (m) - ((sizeof (size_t)) << 1))))) +
		  ((((mchunkptr) ((char *) (m) - ((sizeof (size_t)) << 1))))->
		   head & ~((((size_t) 1)) | (((size_t) 2)) |
			    (((size_t) 4))))));
	      init_top (m, mn,
			(size_t) ((tbase + tsize) - (char *) mn) -
			(((((size_t)
			    (((void *) ((char *) (0) +
					((sizeof (size_t)) << 1)))) &
			    (((size_t) (2 * sizeof (void *))) -
			     ((size_t) 1))) ==
			   0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
				      ((size_t)
				       (((void *) ((char *) (0) +
						   ((sizeof (size_t)) << 1))))
				       & (((size_t) (2 * sizeof (void *))) -
					  ((size_t) 1)))) & (((size_t) (2 *
									sizeof
									(void
									 *)))
							     -
							     ((size_t) 1)))) +
			 (((sizeof (struct malloc_segment)) +
			   ((sizeof (size_t))) +
			   (((size_t) (2 * sizeof (void *))) -
			    ((size_t) 1))) & ~(((size_t) (2 *
							  sizeof (void *))) -
					       ((size_t) 1))) +
			 (((sizeof (mchunk)) +
			   (((size_t) (2 * sizeof (void *))) -
			    ((size_t) 1))) & ~(((size_t) (2 *
							  sizeof (void *))) -
					       ((size_t) 1)))));
	    }

	}
      else
	{
	  msegmentptr sp = &m->seg;
	  while (sp != 0 && tbase != sp->base + sp->size)
	    sp = (0) ? 0 : sp->next;

	  if (sp != 0 && !((sp)->sflags & (8U))
	      && (sp->sflags & (((size_t) 1))) == mmap_flag
	      && ((char *) (m->top) >= sp->base
		  && (char *) (m->top) < sp->base + sp->size))
	    {
	      sp->size += tsize;
	      init_top (m, m->top, m->topsize + tsize);
	    }
	  else
	    {
	      if (tbase < m->least_addr)
		m->least_addr = tbase;

	      sp = &m->seg;
	      while (sp != 0 && sp->base != tbase + tsize)
		sp = (0) ? 0 : sp->next;

	      if (sp != 0 && !((sp)->sflags & (8U))
		  && (sp->sflags & (((size_t) 1))) == mmap_flag)
		{
		  char *oldbase = sp->base;
		  sp->base = tbase;
		  sp->size += tsize;
		  return prepend_alloc (m, tbase, oldbase, nb);
		}
	      else
		add_segment (m, tbase, tsize, mmap_flag);

	    }

	}

      if (nb < m->topsize)
	{
	  size_t rsize = m->topsize -= nb;
	  mchunkptr p = m->top;
	  mchunkptr r = m->top = ((mchunkptr) (((char *) (p)) + (nb)));
	  r->head = rsize | (((size_t) 1));
	  ((p)->head = (nb | (((size_t) 1)) | (((size_t) 2))));
	  ;
	  ;
	  return ((void *) ((char *) (p) + ((sizeof (size_t)) << 1)));
	}

    }

  (*__errno_location ()) = 12;
  ;
  return 0;
}




static size_t
release_unused_segments (mstate m)
{
  size_t released = 0;
  int nsegs = 0;
  msegmentptr pred = &m->seg;
  msegmentptr sp = pred->next;
  while (sp != 0)
    {
      char *base = sp->base;
      size_t size = sp->size;
      msegmentptr next = sp->next;
      ++nsegs;
      if (((sp)->sflags & (((size_t) 1))) && !((sp)->sflags & (8U)))
	{
	  mchunkptr p =
	    (mchunkptr) ((base) +
			 ((((size_t)
			    (((void *) ((char *) (base) +
					((sizeof (size_t)) << 1)))) &
			    (((size_t) (2 * sizeof (void *))) -
			     ((size_t) 1))) ==
			   0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
				      ((size_t)
				       (((void *) ((char *) (base) +
						   ((sizeof (size_t)) << 1))))
				       & (((size_t) (2 * sizeof (void *))) -
					  ((size_t) 1)))) & (((size_t) (2 *
									sizeof
									(void
									 *)))
							     -
							     ((size_t) 1)))));
	  size_t psize =
	    ((p)->
	     head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));

	  if (!
	      (((p)->head & ((((size_t) 1)) | (((size_t) 2)))) !=
	       (((size_t) 1)))
	      && (char *) p + psize >=
	      base + size -
	      (((((size_t)
		  (((void *) ((char *) (0) +
			      ((sizeof (size_t)) << 1)))) & (((size_t) (2 *
									sizeof
									(void
									 *)))
							     -
							     ((size_t) 1))) ==
		 0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
			    ((size_t)
			     (((void *) ((char *) (0) +
					 ((sizeof (size_t)) << 1)))) &
			     (((size_t) (2 * sizeof (void *))) -
			      ((size_t) 1)))) & (((size_t) (2 *
							    sizeof (void *)))
						 - ((size_t) 1)))) +
	       (((sizeof (struct malloc_segment)) + ((sizeof (size_t))) +
		 (((size_t) (2 * sizeof (void *))) -
		  ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				     ((size_t) 1))) + (((sizeof (mchunk)) +
							(((size_t)
							  (2 *
							   sizeof (void *))) -
							 ((size_t) 1))) &
						       ~(((size_t)
							  (2 *
							   sizeof (void *))) -
							 ((size_t) 1)))))
	    {
	      tchunkptr tp = (tchunkptr) p;
	      ;
	      if (p == m->dv)
		{
		  m->dv = 0;
		  m->dvsize = 0;
		}
	      else
		{
		  {
		    tchunkptr XP = tp->parent;
		    tchunkptr R;
		    if (tp->bk != tp)
		      {
			tchunkptr F = tp->fd;
			R = tp->bk;
			if (__builtin_expect
			    (((char *) (F) >= (m)->least_addr) && F->bk == tp
			     && R->fd == tp, 1))
			  {
			    F->bk = R;
			    R->fd = F;
			  }
			else
			  {
			    abort ();
			  }
		      }
		    else
		      {
			tchunkptr *RP;
			if (((R = *(RP = &(tp->child[1]))) != 0)
			    || ((R = *(RP = &(tp->child[0]))) != 0))
			  {
			    tchunkptr *CP;
			    while ((*(CP = &(R->child[1])) != 0)
				   || (*(CP = &(R->child[0])) != 0))
			      {
				R = *(RP = CP);
			      }
			    if (__builtin_expect
				(((char *) (RP) >= (m)->least_addr), 1))
			      *RP = 0;
			    else
			      {
				abort ();
			      }
			  }
		      }
		    if (XP != 0)
		      {
			tbinptr *H = (&((m)->treebins[tp->index]));
			if (tp == *H)
			  {
			    if ((*H = R) == 0)
			      ((m)->treemap &=
			       ~((binmap_t) (1) << (tp->index)));
			  }
			else
			  if (__builtin_expect
			      (((char *) (XP) >= (m)->least_addr), 1))
			  {
			    if (XP->child[0] == tp)
			      XP->child[0] = R;
			    else
			      XP->child[1] = R;
			  }
			else
			  abort ();
			if (R != 0)
			  {
			    if (__builtin_expect
				(((char *) (R) >= (m)->least_addr), 1))
			      {
				tchunkptr C0, C1;
				R->parent = XP;
				if ((C0 = tp->child[0]) != 0)
				  {
				    if (__builtin_expect
					(((char *) (C0) >= (m)->least_addr),
					 1))
				      {
					R->child[0] = C0;
					C0->parent = R;
				      }
				    else
				      abort ();
				  }
				if ((C1 = tp->child[1]) != 0)
				  {
				    if (__builtin_expect
					(((char *) (C1) >= (m)->least_addr),
					 1))
				      {
					R->child[1] = C1;
					C1->parent = R;
				      }
				    else
				      abort ();
				  }
			      }
			    else
			      abort ();
			  }
		      }
		  };
		}
	      if (munmap (((base)), ((size))) == 0)
		{
		  released += size;
		  m->footprint -= size;

		  fprintf (stderr, "memory: %zd\t%p\n", -size, ((void *) 0));

		  sp = pred;
		  sp->next = next;
		}
	      else
		{
		  {
		    tbinptr *H;
		    bindex_t I;
		    {
		      unsigned int X = psize >> (8U);
		      if (X == 0)
			I = 0;
		      else if (X > 0xFFFF)
			I = (32U) - 1;
		      else
			{
			  unsigned int K =
			    (unsigned) sizeof (X) * 8 - 1 -
			    (unsigned) __builtin_clz (X);
			  I =
			    (bindex_t) ((K << 1) +
					((psize >> (K + ((8U) - 1)) & 1)));
		    }};
		    H = (&((m)->treebins[I]));
		    tp->index = I;
		    tp->child[0] = tp->child[1] = 0;
		    if (!((m)->treemap & ((binmap_t) (1) << (I))))
		      {
			((m)->treemap |= ((binmap_t) (1) << (I)));
			*H = tp;
			tp->parent = (tchunkptr) H;
			tp->fd = tp->bk = tp;
		      }
		    else
		      {
			tchunkptr T = *H;
			size_t K =
			  psize << ((I == (32U) - 1) ? 0
				    : (((sizeof (size_t) << 3) -
					((size_t) 1)) - (((I) >> 1) + (8U) -
							 2)));
			for (;;)
			  {
			    if (((T)->
				 head &
				 ~(((((size_t) 1)) | (((size_t) 2)) |
				    (((size_t) 4))))) != psize)
			      {
				tchunkptr *C =
				  &(T->
				    child[(K >>
					   ((sizeof (size_t) << 3) -
					    ((size_t) 1))) & 1]);
				K <<= 1;
				if (*C != 0)
				  T = *C;
				else
				  if (__builtin_expect
				      (((char *) (C) >= (m)->least_addr), 1))
				  {
				    *C = tp;
				    tp->parent = T;
				    tp->fd = tp->bk = tp;
				    break;
				  }
				else
				  {
				    abort ();
				    break;
				  }
			      }
			    else
			      {
				tchunkptr F = T->fd;
				if (__builtin_expect
				    (((char *) (T) >= (m)->least_addr)
				     && ((char *) (F) >= (m)->least_addr), 1))
				  {
				    T->fd = F->bk = tp;
				    tp->fd = F;
				    tp->bk = T;
				    tp->parent = 0;
				    break;
				  }
				else
				  {
				    abort ();
				    break;
				  }
			      }
			  }
		      }
		  };
		}
	    }
	}
      if (0)
	break;
      pred = sp;
      sp = next;
    }

  m->release_checks = (((size_t) nsegs > (size_t) 4095) ?
		       (size_t) nsegs : (size_t) 4095);
  return released;
}

;
static int
sys_trim (mstate m, size_t pad)
{
  size_t released = 0;
  (void) (mparams.magic != 0 || init_mparams ());
  if (pad <
      ((-
	(((sizeof (mchunk)) +
	  (((size_t) (2 * sizeof (void *))) -
	   ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
			      ((size_t) 1)))) << 2) && ((m)->top != 0))
    {
      pad +=
	(((((size_t) (((void *) ((char *) (0) + ((sizeof (size_t)) << 1)))) &
	    (((size_t) (2 * sizeof (void *))) - ((size_t) 1))) ==
	   0) ? 0 : ((((size_t) (2 * sizeof (void *))) -
		      ((size_t)
		       (((void *) ((char *) (0) +
				   ((sizeof (size_t)) << 1)))) & (((size_t) (2
									     *
									     sizeof
									     (void
									      *)))
								  -
								  ((size_t)
								   1)))) &
		     (((size_t) (2 * sizeof (void *))) - ((size_t) 1)))) +
	 (((sizeof (struct malloc_segment)) + ((sizeof (size_t))) +
	   (((size_t) (2 * sizeof (void *))) -
	    ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
			       ((size_t) 1))) + (((sizeof (mchunk)) +
						  (((size_t)
						    (2 * sizeof (void *))) -
						   ((size_t) 1))) &
						 ~(((size_t)
						    (2 * sizeof (void *))) -
						   ((size_t) 1))));
      if (m->topsize > pad)
	{
	  size_t unit = mparams.granularity;
	  size_t extra =
	    ((m->topsize - pad + (unit - ((size_t) 1))) / unit -
	     ((size_t) 1)) * unit;
	  msegmentptr sp = segment_holding (m, (char *) m->top);
	  if (!((sp)->sflags & (8U)))
	    {
	      if (((sp)->sflags & (((size_t) 1))))
		{
		  if (1 && sp->size >= extra && !has_segment_link (m, sp))
		    {
		      size_t newsize = sp->size - extra;
		      (void) newsize;
		      if ((mremap
			   (((sp->base)), ((sp->size)), ((newsize)),
			    ((0))) != ((void *) ((~(size_t) 0))))
			  || (munmap (((sp->base + newsize)), ((extra))) ==
			      0))
			{
			  released = extra;
			  fprintf (stderr, "memory: %zd\t%p\n", -extra,
				   ((void *) 0));
			}

		    }

		}
	      else if (1)
		{
		  if (extra >= ((~(size_t) 0) / 2U))
		    extra = (((~(size_t) 0) / 2U)) + ((size_t) 1) - unit;

		  ;
		  {
		    char *old_br = (char *) (sbrk (0));
		    if (old_br == sp->base + sp->size)
		      {
			char *rel_br = (char *) (sbrk (-extra));
			char *new_br = (char *) (sbrk (0));
			if (rel_br != ((char *) (((void *) ((~(size_t) 0)))))
			    && new_br < old_br)
			  released = old_br - new_br;

			fprintf (stderr, "memory: %zd\t%p\n", -released,
				 sbrk (0));
		      }

		  }
		  ;
		}


	    }

	  if (released != 0)
	    {
	      sp->size -= released;
	      m->footprint -= released;
	      init_top (m, m->top, m->topsize - released);
	      ;
	    }

	}

      if (1)
	released += release_unused_segments (m);

      if (released == 0 && m->topsize > m->trim_check)
	m->trim_check = (~(size_t) 0);

    }

  return (released != 0) ? 1 : 0;
}




static void
dispose_chunk (mstate m, mchunkptr p, size_t psize)
{
  mchunkptr next = ((mchunkptr) (((char *) (p)) + (psize)));
  if (!((p)->head & (((size_t) 1))))
    {
      mchunkptr prev;
      size_t prevsize = p->prev_foot;
      if ((((p)->head & ((((size_t) 1)) | (((size_t) 2)))) == 0))
	{
	  psize += prevsize + (((sizeof (size_t)) << 2));
	  if (munmap ((((char *) p - prevsize)), ((psize))) == 0)
	    {
	      m->footprint -= psize;

	      fprintf (stderr, "memory: %zd\t%p\n", -psize, ((void *) 0));
	    }
	  return;
	}
      prev = ((mchunkptr) (((char *) (p)) - (prevsize)));
      psize += prevsize;
      p = prev;
      if (__builtin_expect (((char *) (prev) >= (m)->least_addr), 1))
	{
	  if (p != m->dv)
	    {
	      if ((((prevsize) >> (3U)) < (32U)))
		{
		  mchunkptr F = p->fd;
		  mchunkptr B = p->bk;
		  bindex_t I = (bindex_t) ((prevsize) >> (3U));;;;
		  if (__builtin_expect
		      (F == ((sbinptr) ((char *) &((m)->smallbins[(I) << 1])))
		       || (((char *) (F) >= (m)->least_addr)
			   && F->bk == p), 1))
		    {
		      if (B == F)
			{
			  ((m)->smallmap &= ~((binmap_t) (1) << (I)));
			}
		      else
			if (__builtin_expect
			    (B ==
			     ((sbinptr)
			      ((char *) &((m)->smallbins[(I) << 1])))
			     || (((char *) (B) >= (m)->least_addr)
				 && B->fd == p), 1))
			{
			  F->bk = B;
			  B->fd = F;
			}
		      else
			{
			  abort ();
			}
		    }
		  else
		    {
		      abort ();
		    }
		}
	      else
		{
		  tchunkptr TP = (tchunkptr) (p);
		  {
		    tchunkptr XP = TP->parent;
		    tchunkptr R;
		    if (TP->bk != TP)
		      {
			tchunkptr F = TP->fd;
			R = TP->bk;
			if (__builtin_expect
			    (((char *) (F) >= (m)->least_addr) && F->bk == TP
			     && R->fd == TP, 1))
			  {
			    F->bk = R;
			    R->fd = F;
			  }
			else
			  {
			    abort ();
			  }
		      }
		    else
		      {
			tchunkptr *RP;
			if (((R = *(RP = &(TP->child[1]))) != 0)
			    || ((R = *(RP = &(TP->child[0]))) != 0))
			  {
			    tchunkptr *CP;
			    while ((*(CP = &(R->child[1])) != 0)
				   || (*(CP = &(R->child[0])) != 0))
			      {
				R = *(RP = CP);
			      }
			    if (__builtin_expect
				(((char *) (RP) >= (m)->least_addr), 1))
			      *RP = 0;
			    else
			      {
				abort ();
			      }
			  }
		      }
		    if (XP != 0)
		      {
			tbinptr *H = (&((m)->treebins[TP->index]));
			if (TP == *H)
			  {
			    if ((*H = R) == 0)
			      ((m)->treemap &=
			       ~((binmap_t) (1) << (TP->index)));
			  }
			else
			  if (__builtin_expect
			      (((char *) (XP) >= (m)->least_addr), 1))
			  {
			    if (XP->child[0] == TP)
			      XP->child[0] = R;
			    else
			      XP->child[1] = R;
			  }
			else
			  abort ();
			if (R != 0)
			  {
			    if (__builtin_expect
				(((char *) (R) >= (m)->least_addr), 1))
			      {
				tchunkptr C0, C1;
				R->parent = XP;
				if ((C0 = TP->child[0]) != 0)
				  {
				    if (__builtin_expect
					(((char *) (C0) >= (m)->least_addr),
					 1))
				      {
					R->child[0] = C0;
					C0->parent = R;
				      }
				    else
				      abort ();
				  }
				if ((C1 = TP->child[1]) != 0)
				  {
				    if (__builtin_expect
					(((char *) (C1) >= (m)->least_addr),
					 1))
				      {
					R->child[1] = C1;
					C1->parent = R;
				      }
				    else
				      abort ();
				  }
			      }
			    else
			      abort ();
			  }
		      }
		  };
		};
	    }
	  else if ((next->head & ((((size_t) 1)) | (((size_t) 2)))) ==
		   ((((size_t) 1)) | (((size_t) 2))))
	    {
	      m->dvsize = psize;
	      (((next)->head &= ~(((size_t) 1))), ((p)->head =
						   (psize | (((size_t) 1))),
						   (((mchunkptr)
						     ((char *) (p) +
						      (psize)))->prev_foot =
						    (psize))));
	      return;
	    }
	}
      else
	{
	  abort ();
	  return;
	}
    }
  if (__builtin_expect (((char *) (next) >= (m)->least_addr), 1))
    {
      if (!((next)->head & (((size_t) 2))))
	{
	  if (next == m->top)
	    {
	      size_t tsize = m->topsize += psize;
	      m->top = p;
	      p->head = tsize | (((size_t) 1));
	      if (p == m->dv)
		{
		  m->dv = 0;
		  m->dvsize = 0;
		}
	      return;
	    }
	  else if (next == m->dv)
	    {
	      size_t dsize = m->dvsize += psize;
	      m->dv = p;
	      ((p)->head =
	       (dsize | (((size_t) 1))),
	       (((mchunkptr) ((char *) (p) + (dsize)))->prev_foot = (dsize)));
	      return;
	    }
	  else
	    {
	      size_t nsize =
		((next)->
		 head &
		 ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));
	      psize += nsize;
	      if ((((nsize) >> (3U)) < (32U)))
		{
		  mchunkptr F = next->fd;
		  mchunkptr B = next->bk;
		  bindex_t I = (bindex_t) ((nsize) >> (3U));;;;
		  if (__builtin_expect
		      (F == ((sbinptr) ((char *) &((m)->smallbins[(I) << 1])))
		       || (((char *) (F) >= (m)->least_addr)
			   && F->bk == next), 1))
		    {
		      if (B == F)
			{
			  ((m)->smallmap &= ~((binmap_t) (1) << (I)));
			}
		      else
			if (__builtin_expect
			    (B ==
			     ((sbinptr)
			      ((char *) &((m)->smallbins[(I) << 1])))
			     || (((char *) (B) >= (m)->least_addr)
				 && B->fd == next), 1))
			{
			  F->bk = B;
			  B->fd = F;
			}
		      else
			{
			  abort ();
			}
		    }
		  else
		    {
		      abort ();
		    }
		}
	      else
		{
		  tchunkptr TP = (tchunkptr) (next);
		  {
		    tchunkptr XP = TP->parent;
		    tchunkptr R;
		    if (TP->bk != TP)
		      {
			tchunkptr F = TP->fd;
			R = TP->bk;
			if (__builtin_expect
			    (((char *) (F) >= (m)->least_addr) && F->bk == TP
			     && R->fd == TP, 1))
			  {
			    F->bk = R;
			    R->fd = F;
			  }
			else
			  {
			    abort ();
			  }
		      }
		    else
		      {
			tchunkptr *RP;
			if (((R = *(RP = &(TP->child[1]))) != 0)
			    || ((R = *(RP = &(TP->child[0]))) != 0))
			  {
			    tchunkptr *CP;
			    while ((*(CP = &(R->child[1])) != 0)
				   || (*(CP = &(R->child[0])) != 0))
			      {
				R = *(RP = CP);
			      }
			    if (__builtin_expect
				(((char *) (RP) >= (m)->least_addr), 1))
			      *RP = 0;
			    else
			      {
				abort ();
			      }
			  }
		      }
		    if (XP != 0)
		      {
			tbinptr *H = (&((m)->treebins[TP->index]));
			if (TP == *H)
			  {
			    if ((*H = R) == 0)
			      ((m)->treemap &=
			       ~((binmap_t) (1) << (TP->index)));
			  }
			else
			  if (__builtin_expect
			      (((char *) (XP) >= (m)->least_addr), 1))
			  {
			    if (XP->child[0] == TP)
			      XP->child[0] = R;
			    else
			      XP->child[1] = R;
			  }
			else
			  abort ();
			if (R != 0)
			  {
			    if (__builtin_expect
				(((char *) (R) >= (m)->least_addr), 1))
			      {
				tchunkptr C0, C1;
				R->parent = XP;
				if ((C0 = TP->child[0]) != 0)
				  {
				    if (__builtin_expect
					(((char *) (C0) >= (m)->least_addr),
					 1))
				      {
					R->child[0] = C0;
					C0->parent = R;
				      }
				    else
				      abort ();
				  }
				if ((C1 = TP->child[1]) != 0)
				  {
				    if (__builtin_expect
					(((char *) (C1) >= (m)->least_addr),
					 1))
				      {
					R->child[1] = C1;
					C1->parent = R;
				      }
				    else
				      abort ();
				  }
			      }
			    else
			      abort ();
			  }
		      }
		  };
		};
	      ((p)->head =
	       (psize | (((size_t) 1))),
	       (((mchunkptr) ((char *) (p) + (psize)))->prev_foot = (psize)));
	      if (p == m->dv)
		{
		  m->dvsize = psize;
		  return;
		}
	    }
	}
      else
	{
	  (((next)->head &= ~(((size_t) 1))), ((p)->head =
					       (psize | (((size_t) 1))),
					       (((mchunkptr)
						 ((char *) (p) +
						  (psize)))->prev_foot =
						(psize))));
	}
      if ((((psize) >> (3U)) < (32U)))
	{
	  bindex_t I = (bindex_t) ((psize) >> (3U));
	  mchunkptr B = ((sbinptr) ((char *) &((m)->smallbins[(I) << 1])));
	  mchunkptr F = B;;
	  if (!((m)->smallmap & ((binmap_t) (1) << (I))))
	    ((m)->smallmap |= ((binmap_t) (1) << (I)));
	  else
	    if (__builtin_expect (((char *) (B->fd) >= (m)->least_addr), 1))
	    F = B->fd;
	  else
	    {
	      abort ();
	    }
	  B->fd = p;
	  F->bk = p;
	  p->fd = F;
	  p->bk = B;
	}
      else
	{
	  tchunkptr TP = (tchunkptr) (p);
	  {
	    tbinptr *H;
	    bindex_t I;
	    {
	      unsigned int X = psize >> (8U);
	      if (X == 0)
		I = 0;
	      else if (X > 0xFFFF)
		I = (32U) - 1;
	      else
		{
		  unsigned int K =
		    (unsigned) sizeof (X) * 8 - 1 -
		    (unsigned) __builtin_clz (X);
		  I =
		    (bindex_t) ((K << 1) + ((psize >> (K + ((8U) - 1)) & 1)));
	    }};
	    H = (&((m)->treebins[I]));
	    TP->index = I;
	    TP->child[0] = TP->child[1] = 0;
	    if (!((m)->treemap & ((binmap_t) (1) << (I))))
	      {
		((m)->treemap |= ((binmap_t) (1) << (I)));
		*H = TP;
		TP->parent = (tchunkptr) H;
		TP->fd = TP->bk = TP;
	      }
	    else
	      {
		tchunkptr T = *H;
		size_t K =
		  psize << ((I == (32U) - 1) ? 0
			    : (((sizeof (size_t) << 3) - ((size_t) 1)) -
			       (((I) >> 1) + (8U) - 2)));
		for (;;)
		  {
		    if (((T)->
			 head &
			 ~(((((size_t) 1)) | (((size_t) 2)) |
			    (((size_t) 4))))) != psize)
		      {
			tchunkptr *C =
			  &(T->
			    child[(K >>
				   ((sizeof (size_t) << 3) -
				    ((size_t) 1))) & 1]);
			K <<= 1;
			if (*C != 0)
			  T = *C;
			else
			  if (__builtin_expect
			      (((char *) (C) >= (m)->least_addr), 1))
			  {
			    *C = TP;
			    TP->parent = T;
			    TP->fd = TP->bk = TP;
			    break;
			  }
			else
			  {
			    abort ();
			    break;
			  }
		      }
		    else
		      {
			tchunkptr F = T->fd;
			if (__builtin_expect
			    (((char *) (T) >= (m)->least_addr)
			     && ((char *) (F) >= (m)->least_addr), 1))
			  {
			    T->fd = F->bk = TP;
			    TP->fd = F;
			    TP->bk = T;
			    TP->parent = 0;
			    break;
			  }
			else
			  {
			    abort ();
			    break;
			  }
		      }
		  }
	      }
	  };
	};
    }
  else
    {
      abort ();
    }
}




static void *
tmalloc_large (mstate m, size_t nb)
{
  tchunkptr v = 0;
  size_t rsize = -nb;
  tchunkptr t;
  bindex_t idx;
  {
    unsigned int X = nb >> (8U);
    if (X == 0)
      idx = 0;
    else if (X > 0xFFFF)
      idx = (32U) - 1;
    else
      {
	unsigned int K =
	  (unsigned) sizeof (X) * 8 - 1 - (unsigned) __builtin_clz (X);
	idx = (bindex_t) ((K << 1) + ((nb >> (K + ((8U) - 1)) & 1)));
  }};
  if ((t = *(&((m)->treebins[idx]))) != 0)
    {

      size_t sizebits =
	nb << ((idx == (32U) - 1) ? 0
	       : (((sizeof (size_t) << 3) - ((size_t) 1)) -
		  (((idx) >> 1) + (8U) - 2)));
      tchunkptr rst = 0;
      for (;;)
	{
	  tchunkptr rt;
	  size_t trem =
	    ((t)->
	     head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4))))) -
	    nb;
	  if (trem < rsize)
	    {
	      v = t;
	      if ((rsize = trem) == 0)
		break;
	    }
	  rt = t->child[1];
	  t =
	    t->
	    child[(sizebits >> ((sizeof (size_t) << 3) - ((size_t) 1))) & 1];
	  if (rt != 0 && rt != t)
	    rst = rt;
	  if (t == 0)
	    {
	      t = rst;
	      break;
	    }
	  sizebits <<= 1;
	}
    }
  if (t == 0 && v == 0)
    {
      binmap_t leftbits =
	((((binmap_t) (1) << (idx)) << 1) | -(((binmap_t) (1) << (idx)) << 1))
	& m->treemap;
      if (leftbits != 0)
	{
	  bindex_t i;
	  binmap_t leastbit = ((leftbits) & -(leftbits));
	  {
	    unsigned int J;
	    J = __builtin_ctz (leastbit);
	    i = (bindex_t) J;
	  };
	  t = *(&((m)->treebins[i]));
	}
    }

  while (t != 0)
    {
      size_t trem =
	((t)->head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4))))) -
	nb;
      if (trem < rsize)
	{
	  rsize = trem;
	  v = t;
	}
      t = ((t)->child[0] != 0 ? (t)->child[0] : (t)->child[1]);
    }


  if (v != 0 && rsize < (size_t) (m->dvsize - nb))
    {
      if (__builtin_expect (((char *) (v) >= (m)->least_addr), 1))
	{
	  mchunkptr r = ((mchunkptr) (((char *) (v)) + (nb)));
	  ;
	  if (__builtin_expect (((char *) (v) < (char *) (r)), 1))
	    {
	      {
		tchunkptr XP = v->parent;
		tchunkptr R;
		if (v->bk != v)
		  {
		    tchunkptr F = v->fd;
		    R = v->bk;
		    if (__builtin_expect
			(((char *) (F) >= (m)->least_addr) && F->bk == v
			 && R->fd == v, 1))
		      {
			F->bk = R;
			R->fd = F;
		      }
		    else
		      {
			abort ();
		      }
		  }
		else
		  {
		    tchunkptr *RP;
		    if (((R = *(RP = &(v->child[1]))) != 0)
			|| ((R = *(RP = &(v->child[0]))) != 0))
		      {
			tchunkptr *CP;
			while ((*(CP = &(R->child[1])) != 0)
			       || (*(CP = &(R->child[0])) != 0))
			  {
			    R = *(RP = CP);
			  }
			if (__builtin_expect
			    (((char *) (RP) >= (m)->least_addr), 1))
			  *RP = 0;
			else
			  {
			    abort ();
			  }
		      }
		  }
		if (XP != 0)
		  {
		    tbinptr *H = (&((m)->treebins[v->index]));
		    if (v == *H)
		      {
			if ((*H = R) == 0)
			  ((m)->treemap &= ~((binmap_t) (1) << (v->index)));
		      }
		    else
		      if (__builtin_expect
			  (((char *) (XP) >= (m)->least_addr), 1))
		      {
			if (XP->child[0] == v)
			  XP->child[0] = R;
			else
			  XP->child[1] = R;
		      }
		    else
		      abort ();
		    if (R != 0)
		      {
			if (__builtin_expect
			    (((char *) (R) >= (m)->least_addr), 1))
			  {
			    tchunkptr C0, C1;
			    R->parent = XP;
			    if ((C0 = v->child[0]) != 0)
			      {
				if (__builtin_expect
				    (((char *) (C0) >= (m)->least_addr), 1))
				  {
				    R->child[0] = C0;
				    C0->parent = R;
				  }
				else
				  abort ();
			      }
			    if ((C1 = v->child[1]) != 0)
			      {
				if (__builtin_expect
				    (((char *) (C1) >= (m)->least_addr), 1))
				  {
				    R->child[1] = C1;
				    C1->parent = R;
				  }
				else
				  abort ();
			      }
			  }
			else
			  abort ();
		      }
		  }
	      };
	      if (rsize <
		  (((sizeof (mchunk)) +
		    (((size_t) (2 * sizeof (void *))) -
		     ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
					((size_t) 1))))
		((v)->head =
		 ((rsize + nb) | (((size_t) 1)) | (((size_t) 2))),
		 ((mchunkptr) (((char *) (v)) + ((rsize + nb))))->head |=
		 (((size_t) 1)));
	      else
		{
		  ((v)->head = (nb | (((size_t) 1)) | (((size_t) 2))));
		  ((r)->head =
		   (rsize | (((size_t) 1))),
		   (((mchunkptr) ((char *) (r) + (rsize)))->prev_foot =
		    (rsize)));
		  if ((((rsize) >> (3U)) < (32U)))
		    {
		      bindex_t I = (bindex_t) ((rsize) >> (3U));
		      mchunkptr B =
			((sbinptr) ((char *) &((m)->smallbins[(I) << 1])));
		      mchunkptr F = B;;
		      if (!((m)->smallmap & ((binmap_t) (1) << (I))))
			((m)->smallmap |= ((binmap_t) (1) << (I)));
		      else
			if (__builtin_expect
			    (((char *) (B->fd) >= (m)->least_addr), 1))
			F = B->fd;
		      else
			{
			  abort ();
			}
		      B->fd = r;
		      F->bk = r;
		      r->fd = F;
		      r->bk = B;
		    }
		  else
		    {
		      tchunkptr TP = (tchunkptr) (r);
		      {
			tbinptr *H;
			bindex_t I;
			{
			  unsigned int X = rsize >> (8U);
			  if (X == 0)
			    I = 0;
			  else if (X > 0xFFFF)
			    I = (32U) - 1;
			  else
			    {
			      unsigned int K =
				(unsigned) sizeof (X) * 8 - 1 -
				(unsigned) __builtin_clz (X);
			      I =
				(bindex_t) ((K << 1) +
					    ((rsize >> (K + ((8U) - 1)) &
					      1)));
			}};
			H = (&((m)->treebins[I]));
			TP->index = I;
			TP->child[0] = TP->child[1] = 0;
			if (!((m)->treemap & ((binmap_t) (1) << (I))))
			  {
			    ((m)->treemap |= ((binmap_t) (1) << (I)));
			    *H = TP;
			    TP->parent = (tchunkptr) H;
			    TP->fd = TP->bk = TP;
			  }
			else
			  {
			    tchunkptr T = *H;
			    size_t K =
			      rsize << ((I == (32U) - 1) ? 0
					: (((sizeof (size_t) << 3) -
					    ((size_t) 1)) - (((I) >> 1) +
							     (8U) - 2)));
			    for (;;)
			      {
				if (((T)->
				     head &
				     ~(((((size_t) 1)) | (((size_t) 2)) |
					(((size_t) 4))))) != rsize)
				  {
				    tchunkptr *C =
				      &(T->
					child[(K >>
					       ((sizeof (size_t) << 3) -
						((size_t) 1))) & 1]);
				    K <<= 1;
				    if (*C != 0)
				      T = *C;
				    else
				      if (__builtin_expect
					  (((char *) (C) >= (m)->least_addr),
					   1))
				      {
					*C = TP;
					TP->parent = T;
					TP->fd = TP->bk = TP;
					break;
				      }
				    else
				      {
					abort ();
					break;
				      }
				  }
				else
				  {
				    tchunkptr F = T->fd;
				    if (__builtin_expect
					(((char *) (T) >= (m)->least_addr)
					 && ((char *) (F) >= (m)->least_addr),
					 1))
				      {
					T->fd = F->bk = TP;
					TP->fd = F;
					TP->bk = T;
					TP->parent = 0;
					break;
				      }
				    else
				      {
					abort ();
					break;
				      }
				  }
			      }
			  }
		      };
		    };
		}
	      return ((void *) ((char *) (v) + ((sizeof (size_t)) << 1)));
	    }
	}
      abort ();
    }
  return 0;
}


static void *
tmalloc_small (mstate m, size_t nb)
{
  tchunkptr t, v;
  size_t rsize;
  bindex_t i;
  binmap_t leastbit = ((m->treemap) & -(m->treemap));
  {
    unsigned int J;
    J = __builtin_ctz (leastbit);
    i = (bindex_t) J;
  };
  v = t = *(&((m)->treebins[i]));
  rsize =
    ((t)->head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4))))) - nb;

  while ((t = ((t)->child[0] != 0 ? (t)->child[0] : (t)->child[1])) != 0)
    {
      size_t trem =
	((t)->head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4))))) -
	nb;
      if (trem < rsize)
	{
	  rsize = trem;
	  v = t;
	}
    }

  if (__builtin_expect (((char *) (v) >= (m)->least_addr), 1))
    {
      mchunkptr r = ((mchunkptr) (((char *) (v)) + (nb)));
      ;
      if (__builtin_expect (((char *) (v) < (char *) (r)), 1))
	{
	  {
	    tchunkptr XP = v->parent;
	    tchunkptr R;
	    if (v->bk != v)
	      {
		tchunkptr F = v->fd;
		R = v->bk;
		if (__builtin_expect
		    (((char *) (F) >= (m)->least_addr) && F->bk == v
		     && R->fd == v, 1))
		  {
		    F->bk = R;
		    R->fd = F;
		  }
		else
		  {
		    abort ();
		  }
	      }
	    else
	      {
		tchunkptr *RP;
		if (((R = *(RP = &(v->child[1]))) != 0)
		    || ((R = *(RP = &(v->child[0]))) != 0))
		  {
		    tchunkptr *CP;
		    while ((*(CP = &(R->child[1])) != 0)
			   || (*(CP = &(R->child[0])) != 0))
		      {
			R = *(RP = CP);
		      }
		    if (__builtin_expect
			(((char *) (RP) >= (m)->least_addr), 1))
		      *RP = 0;
		    else
		      {
			abort ();
		      }
		  }
	      }
	    if (XP != 0)
	      {
		tbinptr *H = (&((m)->treebins[v->index]));
		if (v == *H)
		  {
		    if ((*H = R) == 0)
		      ((m)->treemap &= ~((binmap_t) (1) << (v->index)));
		  }
		else
		  if (__builtin_expect
		      (((char *) (XP) >= (m)->least_addr), 1))
		  {
		    if (XP->child[0] == v)
		      XP->child[0] = R;
		    else
		      XP->child[1] = R;
		  }
		else
		  abort ();
		if (R != 0)
		  {
		    if (__builtin_expect
			(((char *) (R) >= (m)->least_addr), 1))
		      {
			tchunkptr C0, C1;
			R->parent = XP;
			if ((C0 = v->child[0]) != 0)
			  {
			    if (__builtin_expect
				(((char *) (C0) >= (m)->least_addr), 1))
			      {
				R->child[0] = C0;
				C0->parent = R;
			      }
			    else
			      abort ();
			  }
			if ((C1 = v->child[1]) != 0)
			  {
			    if (__builtin_expect
				(((char *) (C1) >= (m)->least_addr), 1))
			      {
				R->child[1] = C1;
				C1->parent = R;
			      }
			    else
			      abort ();
			  }
		      }
		    else
		      abort ();
		  }
	      }
	  };
	  if (rsize <
	      (((sizeof (mchunk)) +
		(((size_t) (2 * sizeof (void *))) -
		 ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				    ((size_t) 1))))
	    ((v)->head =
	     ((rsize + nb) | (((size_t) 1)) | (((size_t) 2))),
	     ((mchunkptr) (((char *) (v)) + ((rsize + nb))))->head |=
	     (((size_t) 1)));
	  else
	    {
	      ((v)->head = (nb | (((size_t) 1)) | (((size_t) 2))));
	      ((r)->head =
	       (rsize | (((size_t) 1))),
	       (((mchunkptr) ((char *) (r) + (rsize)))->prev_foot = (rsize)));
	      {
		size_t DVS = m->dvsize;;
		if (DVS != 0)
		  {
		    mchunkptr DV = m->dv;
		    {
		      bindex_t I = (bindex_t) ((DVS) >> (3U));
		      mchunkptr B =
			((sbinptr) ((char *) &((m)->smallbins[(I) << 1])));
		      mchunkptr F = B;;
		      if (!((m)->smallmap & ((binmap_t) (1) << (I))))
			((m)->smallmap |= ((binmap_t) (1) << (I)));
		      else
			if (__builtin_expect
			    (((char *) (B->fd) >= (m)->least_addr), 1))
			F = B->fd;
		      else
			{
			  abort ();
			}
		      B->fd = DV;
		      F->bk = DV;
		      DV->fd = F;
		      DV->bk = B;
		    };
		  }
		m->dvsize = rsize;
		m->dv = r;
	      };
	    }
	  return ((void *) ((char *) (v) + ((sizeof (size_t)) << 1)));
	}
    }

  abort ();
  return 0;
}



;
void *
malloc (size_t bytes)
{
  if (!(0))
    {
      void *mem;
      size_t nb;
      if (bytes <=
	  (((((size_t) 1) << (8U)) - ((size_t) 1)) -
	   (((size_t) (2 * sizeof (void *))) - ((size_t) 1)) -
	   ((sizeof (size_t)))))
	{
	  bindex_t idx;
	  binmap_t smallbits;
	  nb =
	    (bytes <
	     ((((sizeof (mchunk)) +
		(((size_t) (2 * sizeof (void *))) -
		 ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				    ((size_t) 1))) - ((sizeof (size_t))) -
	      ((size_t) 1))) ? (((sizeof (mchunk)) +
				 (((size_t) (2 * sizeof (void *))) -
				  ((size_t) 1))) & ~(((size_t) (2 *
								sizeof (void
									*))) -
						     ((size_t) 1)))
	    : (((bytes) + ((sizeof (size_t))) +
		(((size_t) (2 * sizeof (void *))) -
		 ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				    ((size_t) 1)));
	  idx = (bindex_t) ((nb) >> (3U));
	  ;
	  smallbits = (&_gm_)->smallmap >> idx;
	  if ((smallbits & 0x3U) != 0)
	    {
	      mchunkptr b, p;
	      idx += ~smallbits & 1;
	      ;
	      b = ((sbinptr) ((char *) &(((&_gm_))->smallbins[(idx) << 1])));
	      p = b->fd;
	      ;
	      {
		mchunkptr F = p->fd;
		;
		;
		;
		if (b == F)
		  {
		    (((&_gm_))->smallmap &= ~((binmap_t) (1) << (idx)));
		  }
		else
		  if (__builtin_expect
		      (((char *) (F) >= ((&_gm_))->least_addr)
		       && F->bk == p, 1))
		  {
		    F->bk = b;
		    b->fd = F;
		  }
		else
		  {
		    abort ();
		  }


	      }
	      ;
	      ((p)->head =
	       (((idx) << (3U)) | (((size_t) 1)) | (((size_t) 2))),
	       ((mchunkptr) (((char *) (p)) + (((idx) << (3U)))))->head |=
	       (((size_t) 1)));
	      mem = ((void *) ((char *) (p) + ((sizeof (size_t)) << 1)));
	      ;
	      goto postaction;
	    }
	  else if (nb > (&_gm_)->dvsize)
	    {
	      if (smallbits != 0)
		{
		  mchunkptr b, p, r;
		  size_t rsize;
		  bindex_t i;
		  binmap_t leftbits =
		    (smallbits << idx) & ((((binmap_t) (1) << (idx)) << 1) |
					  -(((binmap_t) (1) << (idx)) << 1));
		  binmap_t leastbit = ((leftbits) & -(leftbits));
		  {
		    unsigned int J;
		    J = __builtin_ctz (leastbit);
		    i = (bindex_t) J;
		    ;
		  }
		  ;
		  b =
		    ((sbinptr) ((char *) &(((&_gm_))->smallbins[(i) << 1])));
		  p = b->fd;
		  ;
		  {
		    mchunkptr F = p->fd;
		    ;
		    ;
		    ;
		    if (b == F)
		      {
			(((&_gm_))->smallmap &= ~((binmap_t) (1) << (i)));
		      }
		    else
		      if (__builtin_expect
			  (((char *) (F) >= ((&_gm_))->least_addr)
			   && F->bk == p, 1))
		      {
			F->bk = b;
			b->fd = F;
		      }
		    else
		      {
			abort ();
		      }


		  }
		  ;
		  rsize = ((i) << (3U)) - nb;
		  if ((sizeof (size_t)) != 4
		      && rsize <
		      (((sizeof (mchunk)) +
			(((size_t) (2 * sizeof (void *))) -
			 ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
					    ((size_t) 1))))
		    ((p)->head =
		     (((i) << (3U)) | (((size_t) 1)) | (((size_t) 2))),
		     ((mchunkptr) (((char *) (p)) + (((i) << (3U)))))->head |=
		     (((size_t) 1)));
		  else
		    {
		      ((p)->head = (nb | (((size_t) 1)) | (((size_t) 2))));
		      r = ((mchunkptr) (((char *) (p)) + (nb)));
		      ((r)->head =
		       (rsize | (((size_t) 1))),
		       (((mchunkptr) ((char *) (r) + (rsize)))->prev_foot =
			(rsize)));
		      {
			size_t DVS = (&_gm_)->dvsize;
			;
			if (DVS != 0)
			  {
			    mchunkptr DV = (&_gm_)->dv;
			    {
			      bindex_t I = (bindex_t) ((DVS) >> (3U));
			      mchunkptr B =
				((sbinptr)
				 ((char *)
				  &(((&_gm_))->smallbins[(I) << 1])));
			      mchunkptr F = B;
			      ;
			      if (!
				  (((&_gm_))->
				   smallmap & ((binmap_t) (1) << (I))))
				(((&_gm_))->smallmap |=
				 ((binmap_t) (1) << (I)));
			      else
				if (__builtin_expect
				    (((char *) (B->fd) >=
				      ((&_gm_))->least_addr), 1))
				F = B->fd;
			      else
				{
				  abort ();
				}


			      B->fd = DV;
			      F->bk = DV;
			      DV->fd = F;
			      DV->bk = B;
			    }
			    ;
			  }

			(&_gm_)->dvsize = rsize;
			(&_gm_)->dv = r;
		      }
		      ;
		    }

		  mem = ((void *) ((char *) (p) + ((sizeof (size_t)) << 1)));
		  ;
		  goto postaction;
		}
	      else if ((&_gm_)->treemap != 0
		       && (mem = tmalloc_small ((&_gm_), nb)) != 0)
		{
		  ;
		  goto postaction;
		}


	    }


	}
      else if (bytes >=
	       ((-
		 (((sizeof (mchunk)) +
		   (((size_t) (2 * sizeof (void *))) -
		    ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				       ((size_t) 1)))) << 2))
	nb = (~(size_t) 0);
      else
	{
	  nb =
	    (((bytes) + ((sizeof (size_t))) +
	      (((size_t) (2 * sizeof (void *))) -
	       ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				  ((size_t) 1)));
	  if ((&_gm_)->treemap != 0
	      && (mem = tmalloc_large ((&_gm_), nb)) != 0)
	    {
	      ;
	      goto postaction;
	    }

	}


      if (nb <= (&_gm_)->dvsize)
	{
	  size_t rsize = (&_gm_)->dvsize - nb;
	  mchunkptr p = (&_gm_)->dv;
	  if (rsize >=
	      (((sizeof (mchunk)) +
		(((size_t) (2 * sizeof (void *))) -
		 ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				    ((size_t) 1))))
	    {
	      mchunkptr r = (&_gm_)->dv =
		((mchunkptr) (((char *) (p)) + (nb)));
	      (&_gm_)->dvsize = rsize;
	      ((r)->head =
	       (rsize | (((size_t) 1))),
	       (((mchunkptr) ((char *) (r) + (rsize)))->prev_foot = (rsize)));
	      ((p)->head = (nb | (((size_t) 1)) | (((size_t) 2))));
	    }
	  else
	    {
	      size_t dvs = (&_gm_)->dvsize;
	      (&_gm_)->dvsize = 0;
	      (&_gm_)->dv = 0;
	      ((p)->head =
	       (dvs | (((size_t) 1)) | (((size_t) 2))),
	       ((mchunkptr) (((char *) (p)) + (dvs)))->head |=
	       (((size_t) 1)));
	    }

	  mem = ((void *) ((char *) (p) + ((sizeof (size_t)) << 1)));
	  ;
	  goto postaction;
	}
      else if (nb < (&_gm_)->topsize)
	{
	  size_t rsize = (&_gm_)->topsize -= nb;
	  mchunkptr p = (&_gm_)->top;
	  mchunkptr r = (&_gm_)->top = ((mchunkptr) (((char *) (p)) + (nb)));
	  r->head = rsize | (((size_t) 1));
	  ((p)->head = (nb | (((size_t) 1)) | (((size_t) 2))));
	  mem = ((void *) ((char *) (p) + ((sizeof (size_t)) << 1)));
	  ;
	  ;
	  goto postaction;
	}


      mem = sys_alloc ((&_gm_), nb);
    postaction:;
      return mem;
    }

  return 0;
}



void
free (void *mem)
{






  if (mem != 0)
    {
      mchunkptr p = ((mchunkptr) ((char *) (mem) - ((sizeof (size_t)) << 1)));
#4778 "malloc_.c"
      if (!(0))
	{
	  ;
	  if (__builtin_expect
	      (((char *) (p) >= ((&_gm_))->least_addr)
	       && (((p)->head & ((((size_t) 1)) | (((size_t) 2)))) !=
		   (((size_t) 1))), 1))
	    {
	      size_t psize =
		((p)->
		 head &
		 ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));
	      mchunkptr next = ((mchunkptr) (((char *) (p)) + (psize)));
	      if (!((p)->head & (((size_t) 1))))
		{
		  size_t prevsize = p->prev_foot;
		  if ((((p)->head & ((((size_t) 1)) | (((size_t) 2)))) == 0))
		    {
		      psize += prevsize + (((sizeof (size_t)) << 2));
		      if (munmap ((((char *) p - prevsize)), ((psize))) == 0)
			{
			  (&_gm_)->footprint -= psize;

			  fprintf (stderr, "memory: %zd\t%p\n", -psize,
				   ((void *) 0));
			}
		      goto postaction;
		    }
		  else
		    {
		      mchunkptr prev =
			((mchunkptr) (((char *) (p)) - (prevsize)));
		      psize += prevsize;
		      p = prev;
		      if (__builtin_expect
			  (((char *) (prev) >= ((&_gm_))->least_addr), 1))
			{
			  if (p != (&_gm_)->dv)
			    {
			      if ((((prevsize) >> (3U)) < (32U)))
				{
				  mchunkptr F = p->fd;
				  mchunkptr B = p->bk;
				  bindex_t I =
				    (bindex_t) ((prevsize) >> (3U));;;;
				  if (__builtin_expect
				      (F ==
				       ((sbinptr)
					((char *)
					 &(((&_gm_))->smallbins[(I) << 1])))
				       ||
				       (((char *) (F) >=
					 ((&_gm_))->least_addr)
					&& F->bk == p), 1))
				    {
				      if (B == F)
					{
					  (((&_gm_))->smallmap &=
					   ~((binmap_t) (1) << (I)));
					}
				      else
					if (__builtin_expect
					    (B ==
					     ((sbinptr)
					      ((char *)
					       &(((&_gm_))->
						 smallbins[(I) << 1])))
					     ||
					     (((char *) (B) >=
					       ((&_gm_))->least_addr)
					      && B->fd == p), 1))
					{
					  F->bk = B;
					  B->fd = F;
					}
				      else
					{
					  abort ();
					}
				    }
				  else
				    {
				      abort ();
				    }
				}
			      else
				{
				  tchunkptr TP = (tchunkptr) (p);
				  {
				    tchunkptr XP = TP->parent;
				    tchunkptr R;
				    if (TP->bk != TP)
				      {
					tchunkptr F = TP->fd;
					R = TP->bk;
					if (__builtin_expect
					    (((char *) (F) >=
					      ((&_gm_))->least_addr)
					     && F->bk == TP
					     && R->fd == TP, 1))
					  {
					    F->bk = R;
					    R->fd = F;
					  }
					else
					  {
					    abort ();
					  }
				      }
				    else
				      {
					tchunkptr *RP;
					if (((R =
					      *(RP = &(TP->child[1]))) != 0)
					    || ((R = *(RP = &(TP->child[0])))
						!= 0))
					  {
					    tchunkptr *CP;
					    while ((*(CP = &(R->child[1])) !=
						    0)
						   || (*(CP = &(R->child[0]))
						       != 0))
					      {
						R = *(RP = CP);
					      }
					    if (__builtin_expect
						(((char *) (RP) >=
						  ((&_gm_))->least_addr), 1))
					      *RP = 0;
					    else
					      {
						abort ();
					      }
					  }
				      }
				    if (XP != 0)
				      {
					tbinptr *H =
					  (&(((&_gm_))->treebins[TP->index]));
					if (TP == *H)
					  {
					    if ((*H = R) == 0)
					      (((&_gm_))->treemap &=
					       ~((binmap_t) (1) <<
						 (TP->index)));
					  }
					else
					  if (__builtin_expect
					      (((char *) (XP) >=
						((&_gm_))->least_addr), 1))
					  {
					    if (XP->child[0] == TP)
					      XP->child[0] = R;
					    else
					      XP->child[1] = R;
					  }
					else
					  abort ();
					if (R != 0)
					  {
					    if (__builtin_expect
						(((char *) (R) >=
						  ((&_gm_))->least_addr), 1))
					      {
						tchunkptr C0, C1;
						R->parent = XP;
						if ((C0 = TP->child[0]) != 0)
						  {
						    if (__builtin_expect
							(((char *) (C0) >=
							  ((&_gm_))->
							  least_addr), 1))
						      {
							R->child[0] = C0;
							C0->parent = R;
						      }
						    else
						      abort ();
						  }
						if ((C1 = TP->child[1]) != 0)
						  {
						    if (__builtin_expect
							(((char *) (C1) >=
							  ((&_gm_))->
							  least_addr), 1))
						      {
							R->child[1] = C1;
							C1->parent = R;
						      }
						    else
						      abort ();
						  }
					      }
					    else
					      abort ();
					  }
				      }
				  };
				};
			    }
			  else
			    if ((next->
				 head & ((((size_t) 1)) | (((size_t) 2)))) ==
				((((size_t) 1)) | (((size_t) 2))))
			    {
			      (&_gm_)->dvsize = psize;
			      (((next)->head &= ~(((size_t) 1))), ((p)->head =
								   (psize |
								    (((size_t)
								      1))),
								   (((mchunkptr) ((char *) (p) + (psize)))->prev_foot = (psize))));
			      goto postaction;
			    }
			}
		      else
			goto erroraction;
		    }
		}

	      if (__builtin_expect
		  (((char *) (p) < (char *) (next))
		   && ((next)->head & (((size_t) 1))), 1))
		{
		  if (!((next)->head & (((size_t) 2))))
		    {
		      if (next == (&_gm_)->top)
			{
			  size_t tsize = (&_gm_)->topsize += psize;
			  (&_gm_)->top = p;
			  p->head = tsize | (((size_t) 1));
			  if (p == (&_gm_)->dv)
			    {
			      (&_gm_)->dv = 0;
			      (&_gm_)->dvsize = 0;
			    }
			  if (((tsize) > ((&_gm_))->trim_check))
			    sys_trim ((&_gm_), 0);
			  goto postaction;
			}
		      else if (next == (&_gm_)->dv)
			{
			  size_t dsize = (&_gm_)->dvsize += psize;
			  (&_gm_)->dv = p;
			  ((p)->head =
			   (dsize | (((size_t) 1))),
			   (((mchunkptr) ((char *) (p) + (dsize)))->
			    prev_foot = (dsize)));
			  goto postaction;
			}
		      else
			{
			  size_t nsize =
			    ((next)->
			     head &
			     ~(((((size_t) 1)) | (((size_t) 2)) |
				(((size_t) 4)))));
			  psize += nsize;
			  if ((((nsize) >> (3U)) < (32U)))
			    {
			      mchunkptr F = next->fd;
			      mchunkptr B = next->bk;
			      bindex_t I = (bindex_t) ((nsize) >> (3U));;;;
			      if (__builtin_expect
				  (F ==
				   ((sbinptr)
				    ((char *)
				     &(((&_gm_))->smallbins[(I) << 1])))
				   || (((char *) (F) >= ((&_gm_))->least_addr)
				       && F->bk == next), 1))
				{
				  if (B == F)
				    {
				      (((&_gm_))->smallmap &=
				       ~((binmap_t) (1) << (I)));
				    }
				  else
				    if (__builtin_expect
					(B ==
					 ((sbinptr)
					  ((char *)
					   &(((&_gm_))->smallbins[(I) << 1])))
					 ||
					 (((char *) (B) >=
					   ((&_gm_))->least_addr)
					  && B->fd == next), 1))
				    {
				      F->bk = B;
				      B->fd = F;
				    }
				  else
				    {
				      abort ();
				    }
				}
			      else
				{
				  abort ();
				}
			    }
			  else
			    {
			      tchunkptr TP = (tchunkptr) (next);
			      {
				tchunkptr XP = TP->parent;
				tchunkptr R;
				if (TP->bk != TP)
				  {
				    tchunkptr F = TP->fd;
				    R = TP->bk;
				    if (__builtin_expect
					(((char *) (F) >=
					  ((&_gm_))->least_addr)
					 && F->bk == TP && R->fd == TP, 1))
				      {
					F->bk = R;
					R->fd = F;
				      }
				    else
				      {
					abort ();
				      }
				  }
				else
				  {
				    tchunkptr *RP;
				    if (((R = *(RP = &(TP->child[1]))) != 0)
					|| ((R = *(RP = &(TP->child[0]))) !=
					    0))
				      {
					tchunkptr *CP;
					while ((*(CP = &(R->child[1])) != 0)
					       || (*(CP = &(R->child[0])) !=
						   0))
					  {
					    R = *(RP = CP);
					  }
					if (__builtin_expect
					    (((char *) (RP) >=
					      ((&_gm_))->least_addr), 1))
					  *RP = 0;
					else
					  {
					    abort ();
					  }
				      }
				  }
				if (XP != 0)
				  {
				    tbinptr *H =
				      (&(((&_gm_))->treebins[TP->index]));
				    if (TP == *H)
				      {
					if ((*H = R) == 0)
					  (((&_gm_))->treemap &=
					   ~((binmap_t) (1) << (TP->index)));
				      }
				    else
				      if (__builtin_expect
					  (((char *) (XP) >=
					    ((&_gm_))->least_addr), 1))
				      {
					if (XP->child[0] == TP)
					  XP->child[0] = R;
					else
					  XP->child[1] = R;
				      }
				    else
				      abort ();
				    if (R != 0)
				      {
					if (__builtin_expect
					    (((char *) (R) >=
					      ((&_gm_))->least_addr), 1))
					  {
					    tchunkptr C0, C1;
					    R->parent = XP;
					    if ((C0 = TP->child[0]) != 0)
					      {
						if (__builtin_expect
						    (((char *) (C0) >=
						      ((&_gm_))->least_addr),
						     1))
						  {
						    R->child[0] = C0;
						    C0->parent = R;
						  }
						else
						  abort ();
					      }
					    if ((C1 = TP->child[1]) != 0)
					      {
						if (__builtin_expect
						    (((char *) (C1) >=
						      ((&_gm_))->least_addr),
						     1))
						  {
						    R->child[1] = C1;
						    C1->parent = R;
						  }
						else
						  abort ();
					      }
					  }
					else
					  abort ();
				      }
				  }
			      };
			    };
			  ((p)->head =
			   (psize | (((size_t) 1))),
			   (((mchunkptr) ((char *) (p) + (psize)))->
			    prev_foot = (psize)));
			  if (p == (&_gm_)->dv)
			    {
			      (&_gm_)->dvsize = psize;
			      goto postaction;
			    }
			}
		    }
		  else
		    (((next)->head &= ~(((size_t) 1))), ((p)->head =
							 (psize |
							  (((size_t) 1))),
							 (((mchunkptr)
							   ((char *) (p) +
							    (psize)))->
							  prev_foot =
							  (psize))));

		  if ((((psize) >> (3U)) < (32U)))
		    {
		      {
			bindex_t I = (bindex_t) ((psize) >> (3U));
			mchunkptr B =
			  ((sbinptr)
			   ((char *) &(((&_gm_))->smallbins[(I) << 1])));
			mchunkptr F = B;;
			if (!(((&_gm_))->smallmap & ((binmap_t) (1) << (I))))
			  (((&_gm_))->smallmap |= ((binmap_t) (1) << (I)));
			else
			  if (__builtin_expect
			      (((char *) (B->fd) >= ((&_gm_))->least_addr),
			       1))
			  F = B->fd;
			else
			  {
			    abort ();
			  }
			B->fd = p;
			F->bk = p;
			p->fd = F;
			p->bk = B;
		      };
		      ;
		    }
		  else
		    {
		      tchunkptr tp = (tchunkptr) p;
		      {
			tbinptr *H;
			bindex_t I;
			{
			  unsigned int X = psize >> (8U);
			  if (X == 0)
			    I = 0;
			  else if (X > 0xFFFF)
			    I = (32U) - 1;
			  else
			    {
			      unsigned int K =
				(unsigned) sizeof (X) * 8 - 1 -
				(unsigned) __builtin_clz (X);
			      I =
				(bindex_t) ((K << 1) +
					    ((psize >> (K + ((8U) - 1)) &
					      1)));
			}};
			H = (&(((&_gm_))->treebins[I]));
			tp->index = I;
			tp->child[0] = tp->child[1] = 0;
			if (!(((&_gm_))->treemap & ((binmap_t) (1) << (I))))
			  {
			    (((&_gm_))->treemap |= ((binmap_t) (1) << (I)));
			    *H = tp;
			    tp->parent = (tchunkptr) H;
			    tp->fd = tp->bk = tp;
			  }
			else
			  {
			    tchunkptr T = *H;
			    size_t K =
			      psize << ((I == (32U) - 1) ? 0
					: (((sizeof (size_t) << 3) -
					    ((size_t) 1)) - (((I) >> 1) +
							     (8U) - 2)));
			    for (;;)
			      {
				if (((T)->
				     head &
				     ~(((((size_t) 1)) | (((size_t) 2)) |
					(((size_t) 4))))) != psize)
				  {
				    tchunkptr *C =
				      &(T->
					child[(K >>
					       ((sizeof (size_t) << 3) -
						((size_t) 1))) & 1]);
				    K <<= 1;
				    if (*C != 0)
				      T = *C;
				    else
				      if (__builtin_expect
					  (((char *) (C) >=
					    ((&_gm_))->least_addr), 1))
				      {
					*C = tp;
					tp->parent = T;
					tp->fd = tp->bk = tp;
					break;
				      }
				    else
				      {
					abort ();
					break;
				      }
				  }
				else
				  {
				    tchunkptr F = T->fd;
				    if (__builtin_expect
					(((char *) (T) >=
					  ((&_gm_))->least_addr)
					 && ((char *) (F) >=
					     ((&_gm_))->least_addr), 1))
				      {
					T->fd = F->bk = tp;
					tp->fd = F;
					tp->bk = T;
					tp->parent = 0;
					break;
				      }
				    else
				      {
					abort ();
					break;
				      }
				  }
			      }
			  }
		      };
		      ;
		      if (--(&_gm_)->release_checks == 0)
			release_unused_segments ((&_gm_));
		    }
		  goto postaction;
		}
	    }
	erroraction:
	  abort ();
	postaction:
	  ;
	}
    }



}

void *
calloc (size_t n_elements, size_t elem_size)
{
  void *mem;
  size_t req = 0;
  if (n_elements != 0)
    {
      req = n_elements * elem_size;
      if (((n_elements | elem_size) & ~(size_t) 0xffff) &&
	  (req / n_elements != elem_size))
	req = (~(size_t) 0);
    }
  mem = malloc (req);
  if (mem != 0
      &&
      (!(((((mchunkptr) ((char *) (mem) - ((sizeof (size_t)) << 1))))->
	  head & ((((size_t) 1)) | (((size_t) 2)))) == 0)))
    memset (mem, 0, req);
  return mem;
}






static mchunkptr
try_realloc_chunk (mstate m, mchunkptr p, size_t nb, int can_move)
{
  mchunkptr newp = 0;
  size_t oldsize =
    ((p)->head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));
  mchunkptr next = ((mchunkptr) (((char *) (p)) + (oldsize)));
  if (__builtin_expect
      (((char *) (p) >= (m)->least_addr)
       && (((p)->head & ((((size_t) 1)) | (((size_t) 2)))) != (((size_t) 1)))
       && ((char *) (p) < (char *) (next))
       && ((next)->head & (((size_t) 1))), 1))
    {
      if ((((p)->head & ((((size_t) 1)) | (((size_t) 2)))) == 0))
	{
	  newp = mmap_resize (m, p, nb, can_move);
	}
      else if (oldsize >= nb)
	{
	  size_t rsize = oldsize - nb;
	  if (rsize >=
	      (((sizeof (mchunk)) +
		(((size_t) (2 * sizeof (void *))) -
		 ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				    ((size_t) 1))))
	    {
	      mchunkptr r = ((mchunkptr) (((char *) (p)) + (nb)));
	      ((p)->head =
	       (((p)->head & (((size_t) 1))) | nb | (((size_t) 2))),
	       ((mchunkptr) (((char *) (p)) + (nb)))->head |= (((size_t) 1)));
	      ((r)->head =
	       (((r)->head & (((size_t) 1))) | rsize | (((size_t) 2))),
	       ((mchunkptr) (((char *) (r)) + (rsize)))->head |=
	       (((size_t) 1)));
	      dispose_chunk (m, r, rsize);
	    }
	  newp = p;
	}
      else if (next == m->top)
	{
	  if (oldsize + m->topsize > nb)
	    {
	      size_t newsize = oldsize + m->topsize;
	      size_t newtopsize = newsize - nb;
	      mchunkptr newtop = ((mchunkptr) (((char *) (p)) + (nb)));
	      ((p)->head =
	       (((p)->head & (((size_t) 1))) | nb | (((size_t) 2))),
	       ((mchunkptr) (((char *) (p)) + (nb)))->head |= (((size_t) 1)));
	      newtop->head = newtopsize | (((size_t) 1));
	      m->top = newtop;
	      m->topsize = newtopsize;
	      newp = p;
	    }
	}
      else if (next == m->dv)
	{
	  size_t dvs = m->dvsize;
	  if (oldsize + dvs >= nb)
	    {
	      size_t dsize = oldsize + dvs - nb;
	      if (dsize >=
		  (((sizeof (mchunk)) +
		    (((size_t) (2 * sizeof (void *))) -
		     ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
					((size_t) 1))))
		{
		  mchunkptr r = ((mchunkptr) (((char *) (p)) + (nb)));
		  mchunkptr n = ((mchunkptr) (((char *) (r)) + (dsize)));
		  ((p)->head =
		   (((p)->head & (((size_t) 1))) | nb | (((size_t) 2))),
		   ((mchunkptr) (((char *) (p)) + (nb)))->head |=
		   (((size_t) 1)));
		  ((r)->head =
		   (dsize | (((size_t) 1))),
		   (((mchunkptr) ((char *) (r) + (dsize)))->prev_foot =
		    (dsize)));
		  ((n)->head &= ~(((size_t) 1)));
		  m->dvsize = dsize;
		  m->dv = r;
		}
	      else
		{
		  size_t newsize = oldsize + dvs;
		  ((p)->head =
		   (((p)->head & (((size_t) 1))) | newsize | (((size_t) 2))),
		   ((mchunkptr) (((char *) (p)) + (newsize)))->head |=
		   (((size_t) 1)));
		  m->dvsize = 0;
		  m->dv = 0;
		}
	      newp = p;
	    }
	}
      else if (!((next)->head & (((size_t) 2))))
	{
	  size_t nextsize =
	    ((next)->
	     head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));
	  if (oldsize + nextsize >= nb)
	    {
	      size_t rsize = oldsize + nextsize - nb;
	      if ((((nextsize) >> (3U)) < (32U)))
		{
		  mchunkptr F = next->fd;
		  mchunkptr B = next->bk;
		  bindex_t I = (bindex_t) ((nextsize) >> (3U));;;;
		  if (__builtin_expect
		      (F == ((sbinptr) ((char *) &((m)->smallbins[(I) << 1])))
		       || (((char *) (F) >= (m)->least_addr)
			   && F->bk == next), 1))
		    {
		      if (B == F)
			{
			  ((m)->smallmap &= ~((binmap_t) (1) << (I)));
			}
		      else
			if (__builtin_expect
			    (B ==
			     ((sbinptr)
			      ((char *) &((m)->smallbins[(I) << 1])))
			     || (((char *) (B) >= (m)->least_addr)
				 && B->fd == next), 1))
			{
			  F->bk = B;
			  B->fd = F;
			}
		      else
			{
			  abort ();
			}
		    }
		  else
		    {
		      abort ();
		    }
		}
	      else
		{
		  tchunkptr TP = (tchunkptr) (next);
		  {
		    tchunkptr XP = TP->parent;
		    tchunkptr R;
		    if (TP->bk != TP)
		      {
			tchunkptr F = TP->fd;
			R = TP->bk;
			if (__builtin_expect
			    (((char *) (F) >= (m)->least_addr) && F->bk == TP
			     && R->fd == TP, 1))
			  {
			    F->bk = R;
			    R->fd = F;
			  }
			else
			  {
			    abort ();
			  }
		      }
		    else
		      {
			tchunkptr *RP;
			if (((R = *(RP = &(TP->child[1]))) != 0)
			    || ((R = *(RP = &(TP->child[0]))) != 0))
			  {
			    tchunkptr *CP;
			    while ((*(CP = &(R->child[1])) != 0)
				   || (*(CP = &(R->child[0])) != 0))
			      {
				R = *(RP = CP);
			      }
			    if (__builtin_expect
				(((char *) (RP) >= (m)->least_addr), 1))
			      *RP = 0;
			    else
			      {
				abort ();
			      }
			  }
		      }
		    if (XP != 0)
		      {
			tbinptr *H = (&((m)->treebins[TP->index]));
			if (TP == *H)
			  {
			    if ((*H = R) == 0)
			      ((m)->treemap &=
			       ~((binmap_t) (1) << (TP->index)));
			  }
			else
			  if (__builtin_expect
			      (((char *) (XP) >= (m)->least_addr), 1))
			  {
			    if (XP->child[0] == TP)
			      XP->child[0] = R;
			    else
			      XP->child[1] = R;
			  }
			else
			  abort ();
			if (R != 0)
			  {
			    if (__builtin_expect
				(((char *) (R) >= (m)->least_addr), 1))
			      {
				tchunkptr C0, C1;
				R->parent = XP;
				if ((C0 = TP->child[0]) != 0)
				  {
				    if (__builtin_expect
					(((char *) (C0) >= (m)->least_addr),
					 1))
				      {
					R->child[0] = C0;
					C0->parent = R;
				      }
				    else
				      abort ();
				  }
				if ((C1 = TP->child[1]) != 0)
				  {
				    if (__builtin_expect
					(((char *) (C1) >= (m)->least_addr),
					 1))
				      {
					R->child[1] = C1;
					C1->parent = R;
				      }
				    else
				      abort ();
				  }
			      }
			    else
			      abort ();
			  }
		      }
		  };
		};
	      if (rsize <
		  (((sizeof (mchunk)) +
		    (((size_t) (2 * sizeof (void *))) -
		     ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
					((size_t) 1))))
		{
		  size_t newsize = oldsize + nextsize;
		  ((p)->head =
		   (((p)->head & (((size_t) 1))) | newsize | (((size_t) 2))),
		   ((mchunkptr) (((char *) (p)) + (newsize)))->head |=
		   (((size_t) 1)));
		}
	      else
		{
		  mchunkptr r = ((mchunkptr) (((char *) (p)) + (nb)));
		  ((p)->head =
		   (((p)->head & (((size_t) 1))) | nb | (((size_t) 2))),
		   ((mchunkptr) (((char *) (p)) + (nb)))->head |=
		   (((size_t) 1)));
		  ((r)->head =
		   (((r)->head & (((size_t) 1))) | rsize | (((size_t) 2))),
		   ((mchunkptr) (((char *) (r)) + (rsize)))->head |=
		   (((size_t) 1)));
		  dispose_chunk (m, r, rsize);
		}
	      newp = p;
	    }
	}
    }
  else
    {
      abort ();
    }
  return newp;
}

static void *
internal_memalign (mstate m, size_t alignment, size_t bytes)
{
  void *mem = 0;
  if (alignment <
      (((sizeof (mchunk)) +
	(((size_t) (2 * sizeof (void *))) -
	 ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) - ((size_t) 1))))
    alignment =
      (((sizeof (mchunk)) +
	(((size_t) (2 * sizeof (void *))) -
	 ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) - ((size_t) 1)));
  if ((alignment & (alignment - ((size_t) 1))) != 0)
    {
      size_t a = ((size_t) (2 * sizeof (void *))) << 1;
      while (a < alignment)
	a <<= 1;
      alignment = a;
    }
  if (bytes >=
      ((-
	(((sizeof (mchunk)) +
	  (((size_t) (2 * sizeof (void *))) -
	   ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
			      ((size_t) 1)))) << 2) - alignment)
    {
      if (m != 0)
	{
	  (*__errno_location ()) = 12;;
	}
    }
  else
    {
      size_t nb =
	(((bytes) <
	  ((((sizeof (mchunk)) +
	     (((size_t) (2 * sizeof (void *))) -
	      ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				 ((size_t) 1))) - ((sizeof (size_t))) -
	   ((size_t) 1))) ? (((sizeof (mchunk)) +
			      (((size_t) (2 * sizeof (void *))) -
			       ((size_t) 1))) & ~(((size_t) (2 *
							     sizeof (void *)))
						  -
						  ((size_t) 1))) : (((bytes) +
								     ((sizeof
								       (size_t)))
								     +
								     (((size_t) (2 * sizeof (void *))) - ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) - ((size_t) 1))));
      size_t req =
	nb + alignment +
	(((sizeof (mchunk)) +
	  (((size_t) (2 * sizeof (void *))) -
	   ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
			      ((size_t) 1))) - ((sizeof (size_t)));
      mem = malloc (req);
      if (mem != 0)
	{
	  mchunkptr p =
	    ((mchunkptr) ((char *) (mem) - ((sizeof (size_t)) << 1)));
	  if ((0))
	    return 0;
	  if ((((size_t) (mem)) & (alignment - 1)) != 0)
	    {
#5002 "malloc_.c"
	      char *br =
		(char
		 *) ((mchunkptr) ((char
				   *) ((size_t) (((size_t)
						  ((char *) mem + alignment -
						   ((size_t) 1))) &
						 -alignment)) -
				  ((sizeof (size_t)) << 1)));
	      char *pos =
		((size_t) (br - (char *) (p)) >=
		 (((sizeof (mchunk)) +
		   (((size_t) (2 * sizeof (void *))) -
		    ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				       ((size_t) 1)))) ? br : br + alignment;
	      mchunkptr newp = (mchunkptr) pos;
	      size_t leadsize = pos - (char *) (p);
	      size_t newsize =
		((p)->
		 head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))))
		- leadsize;

	      if ((((p)->head & ((((size_t) 1)) | (((size_t) 2)))) == 0))
		{
		  newp->prev_foot = p->prev_foot + leadsize;
		  newp->head = newsize;
		}
	      else
		{
		  ((newp)->head =
		   (((newp)->
		     head & (((size_t) 1))) | newsize | (((size_t) 2))),
		   ((mchunkptr) (((char *) (newp)) + (newsize)))->head |=
		   (((size_t) 1)));
		  ((p)->head =
		   (((p)->head & (((size_t) 1))) | leadsize | (((size_t) 2))),
		   ((mchunkptr) (((char *) (p)) + (leadsize)))->head |=
		   (((size_t) 1)));
		  dispose_chunk (m, p, leadsize);
		}
	      p = newp;
	    }


	  if (!(((p)->head & ((((size_t) 1)) | (((size_t) 2)))) == 0))
	    {
	      size_t size =
		((p)->
		 head &
		 ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));
	      if (size >
		  nb +
		  (((sizeof (mchunk)) +
		    (((size_t) (2 * sizeof (void *))) -
		     ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
					((size_t) 1))))
		{
		  size_t remainder_size = size - nb;
		  mchunkptr remainder = ((mchunkptr) (((char *) (p)) + (nb)));
		  ((p)->head =
		   (((p)->head & (((size_t) 1))) | nb | (((size_t) 2))),
		   ((mchunkptr) (((char *) (p)) + (nb)))->head |=
		   (((size_t) 1)));
		  ((remainder)->head =
		   (((remainder)->
		     head & (((size_t) 1))) | remainder_size | (((size_t)
								 2))),
		   ((mchunkptr) (((char *) (remainder)) + (remainder_size)))->
		   head |= (((size_t) 1)));
		  dispose_chunk (m, remainder, remainder_size);
		}
	    }

	  mem = ((void *) ((char *) (p) + ((sizeof (size_t)) << 1)));
	  ;
	  ;
	  ;
	  ;
	}
    }
  return mem;
}

#5052 "malloc_.c"
static void **
ialloc (mstate m, size_t n_elements, size_t * sizes, int opts, void *chunks[])
{

  size_t element_size;
  size_t contents_size;
  size_t array_size;
  void *mem;
  mchunkptr p;
  size_t remainder_size;
  void **marray;
  mchunkptr array_chunk;
  flag_t was_enabled;
  size_t size;
  size_t i;

  (void) (mparams.magic != 0 || init_mparams ());

  if (chunks != 0)
    {
      if (n_elements == 0)
	return chunks;
      marray = chunks;
      array_size = 0;
    }
  else
    {

      if (n_elements == 0)
	return (void **) malloc (0);
      marray = 0;
      array_size =
	(((n_elements * (sizeof (void *))) <
	  ((((sizeof (mchunk)) +
	     (((size_t) (2 * sizeof (void *))) -
	      ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				 ((size_t) 1))) - ((sizeof (size_t))) -
	   ((size_t) 1))) ? (((sizeof (mchunk)) +
			      (((size_t) (2 * sizeof (void *))) -
			       ((size_t) 1))) & ~(((size_t) (2 *
							     sizeof (void *)))
						  -
						  ((size_t) 1)))
	 : (((n_elements * (sizeof (void *))) + ((sizeof (size_t))) +
	     (((size_t) (2 * sizeof (void *))) -
	      ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				 ((size_t) 1))));
    }


  if (opts & 0x1)
    {
      element_size =
	(((*sizes) <
	  ((((sizeof (mchunk)) +
	     (((size_t) (2 * sizeof (void *))) -
	      ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				 ((size_t) 1))) - ((sizeof (size_t))) -
	   ((size_t) 1))) ? (((sizeof (mchunk)) +
			      (((size_t) (2 * sizeof (void *))) -
			       ((size_t) 1))) & ~(((size_t) (2 *
							     sizeof (void *)))
						  -
						  ((size_t) 1))) : (((*sizes)
								     +
								     ((sizeof
								       (size_t)))
								     +
								     (((size_t) (2 * sizeof (void *))) - ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) - ((size_t) 1))));
      contents_size = n_elements * element_size;
    }
  else
    {
      element_size = 0;
      contents_size = 0;
      for (i = 0; i != n_elements; ++i)
	contents_size +=
	  (((sizes[i]) <
	    ((((sizeof (mchunk)) +
	       (((size_t) (2 * sizeof (void *))) -
		((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				   ((size_t) 1))) - ((sizeof (size_t))) -
	     ((size_t) 1))) ? (((sizeof (mchunk)) +
				(((size_t) (2 * sizeof (void *))) -
				 ((size_t) 1))) & ~(((size_t) (2 *
							       sizeof (void
								       *))) -
						    ((size_t) 1)))
	   : (((sizes[i]) + ((sizeof (size_t))) +
	       (((size_t) (2 * sizeof (void *))) -
		((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				   ((size_t) 1))));
    }

  size = contents_size + array_size;






  was_enabled = ((m)->mflags & (((size_t) 1)));
  ((m)->mflags &= ~(((size_t) 1)));
  mem = malloc (size - ((sizeof (size_t))));
  if (was_enabled)
    ((m)->mflags |= (((size_t) 1)));
  if (mem == 0)
    return 0;

  if ((0))
    return 0;
  p = ((mchunkptr) ((char *) (mem) - ((sizeof (size_t)) << 1)));
  remainder_size =
    ((p)->head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));

  ;

  if (opts & 0x2)
    {
      memset ((size_t *) mem, 0,
	      remainder_size - (sizeof (size_t)) - array_size);
    }


  if (marray == 0)
    {
      size_t array_chunk_size;
      array_chunk = ((mchunkptr) (((char *) (p)) + (contents_size)));
      array_chunk_size = remainder_size - contents_size;
      marray =
	(void
	 **) (((void *) ((char *) (array_chunk) + ((sizeof (size_t)) << 1))));
      ((array_chunk)->head =
       (array_chunk_size | (((size_t) 1)) | (((size_t) 2))));
      remainder_size = contents_size;
    }


  for (i = 0;; ++i)
    {
      marray[i] = ((void *) ((char *) (p) + ((sizeof (size_t)) << 1)));
      if (i != n_elements - 1)
	{
	  if (element_size != 0)
	    size = element_size;
	  else
	    size =
	      (((sizes[i]) <
		((((sizeof (mchunk)) +
		   (((size_t) (2 * sizeof (void *))) -
		    ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				       ((size_t) 1))) - ((sizeof (size_t))) -
		 ((size_t) 1))) ? (((sizeof (mchunk)) +
				    (((size_t) (2 * sizeof (void *))) -
				     ((size_t) 1))) & ~(((size_t) (2 *
								   sizeof
								   (void *)))
							-
							((size_t) 1)))
	       : (((sizes[i]) + ((sizeof (size_t))) +
		   (((size_t) (2 * sizeof (void *))) -
		    ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				       ((size_t) 1))));
	  remainder_size -= size;
	  ((p)->head = (size | (((size_t) 1)) | (((size_t) 2))));
	  p = ((mchunkptr) (((char *) (p)) + (size)));
	}
      else
	{
	  ((p)->head = (remainder_size | (((size_t) 1)) | (((size_t) 2))));
	  break;
	}
    }
#5167 "malloc_.c"
  ;
  return marray;
}

#5178 "malloc_.c"
static size_t
internal_bulk_free (mstate m, void *array[], size_t nelem)
{
  size_t unfreed = 0;
  if (!(0))
    {
      void **a;
      void **fence = &(array[nelem]);
      for (a = array; a != fence; ++a)
	{
	  void *mem = *a;
	  if (mem != 0)
	    {
	      mchunkptr p =
		((mchunkptr) ((char *) (mem) - ((sizeof (size_t)) << 1)));
	      size_t psize =
		((p)->
		 head &
		 ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))));






	      ;
	      *a = 0;
	      if (__builtin_expect
		  (((char *) (p) >= (m)->least_addr)
		   && (((p)->head & ((((size_t) 1)) | (((size_t) 2)))) !=
		       (((size_t) 1))), 1))
		{
		  void **b = a + 1;
		  mchunkptr next =
		    ((mchunkptr)
		     (((char *) (p)) +
		      ((p)->
		       head & ~((((size_t) 1)) | (((size_t) 2)) |
				(((size_t) 4))))));
		  if (b != fence
		      && *b ==
		      ((void *) ((char *) (next) + ((sizeof (size_t)) << 1))))
		    {
		      size_t newsize =
			((next)->
			 head &
			 ~(((((size_t) 1)) | (((size_t) 2)) |
			    (((size_t) 4))))) + psize;
		      ((p)->head =
		       (((p)->
			 head & (((size_t) 1))) | newsize | (((size_t) 2))),
		       ((mchunkptr) (((char *) (p)) + (newsize)))->head |=
		       (((size_t) 1)));
		      *b =
			((void *) ((char *) (p) + ((sizeof (size_t)) << 1)));
		    }
		  else
		    dispose_chunk (m, p, psize);
		}
	      else
		{
		  abort ();
		  break;
		}
	    }
	}
      if (((m->topsize) > (m)->trim_check))
	sys_trim (m, 0);
      ;
    }
  return unfreed;
}

#5266 "malloc_.c"
void *
realloc (void *oldmem, size_t bytes)
{
  void *mem = 0;
  if (oldmem == 0)
    {
      mem = malloc (bytes);
    }
  else if (bytes >=
	   ((-
	     (((sizeof (mchunk)) +
	       (((size_t) (2 * sizeof (void *))) -
		((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				   ((size_t) 1)))) << 2))
    {
      (*__errno_location ()) = 12;;
    }





  else
    {
      size_t nb =
	(((bytes) <
	  ((((sizeof (mchunk)) +
	     (((size_t) (2 * sizeof (void *))) -
	      ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				 ((size_t) 1))) - ((sizeof (size_t))) -
	   ((size_t) 1))) ? (((sizeof (mchunk)) +
			      (((size_t) (2 * sizeof (void *))) -
			       ((size_t) 1))) & ~(((size_t) (2 *
							     sizeof (void *)))
						  -
						  ((size_t) 1))) : (((bytes) +
								     ((sizeof
								       (size_t)))
								     +
								     (((size_t) (2 * sizeof (void *))) - ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) - ((size_t) 1))));
      mchunkptr oldp =
	((mchunkptr) ((char *) (oldmem) - ((sizeof (size_t)) << 1)));

      mstate m = (&_gm_);







      if (!(0))
	{
	  mchunkptr newp = try_realloc_chunk (m, oldp, nb, 1);
	  ;
	  if (newp != 0)
	    {
	      ;
	      mem = ((void *) ((char *) (newp) + ((sizeof (size_t)) << 1)));
	    }
	  else
	    {
	      mem = malloc (bytes);
	      if (mem != 0)
		{
		  size_t oc =
		    ((oldp)->
		     head &
		     ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4))))) -
		    ((((oldp)->head & ((((size_t) 1)) | (((size_t) 2)))) ==
		      0) ? (((sizeof (size_t)) << 1)) : ((sizeof (size_t))));
		  memcpy (mem, oldmem, (oc < bytes) ? oc : bytes);
		  free (oldmem);
		}
	    }
	}
    }
  return mem;
}

void *
realloc_in_place (void *oldmem, size_t bytes)
{
  void *mem = 0;
  if (oldmem != 0)
    {
      if (bytes >=
	  ((-
	    (((sizeof (mchunk)) +
	      (((size_t) (2 * sizeof (void *))) -
	       ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				  ((size_t) 1)))) << 2))
	{
	  (*__errno_location ()) = 12;;
	}
      else
	{
	  size_t nb =
	    (((bytes) <
	      ((((sizeof (mchunk)) +
		 (((size_t) (2 * sizeof (void *))) -
		  ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				     ((size_t) 1))) - ((sizeof (size_t))) -
	       ((size_t) 1))) ? (((sizeof (mchunk)) +
				  (((size_t) (2 * sizeof (void *))) -
				   ((size_t) 1))) & ~(((size_t) (2 *
								 sizeof (void
									 *)))
						      -
						      ((size_t) 1)))
	     : (((bytes) + ((sizeof (size_t))) +
		 (((size_t) (2 * sizeof (void *))) -
		  ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				     ((size_t) 1))));
	  mchunkptr oldp =
	    ((mchunkptr) ((char *) (oldmem) - ((sizeof (size_t)) << 1)));

	  mstate m = (&_gm_);







	  if (!(0))
	    {
	      mchunkptr newp = try_realloc_chunk (m, oldp, nb, 0);
	      ;
	      if (newp == oldp)
		{
		  ;
		  mem = oldmem;
		}
	    }
	}
    }
  return mem;
}

void *
memalign (size_t alignment, size_t bytes)
{
  if (alignment <= ((size_t) (2 * sizeof (void *))))
    {
      return malloc (bytes);
    }
  return internal_memalign ((&_gm_), alignment, bytes);
}

int
posix_memalign (void **pp, size_t alignment, size_t bytes)
{
  void *mem = 0;
  if (alignment == ((size_t) (2 * sizeof (void *))))
    mem = malloc (bytes);
  else
    {
      size_t d = alignment / sizeof (void *);
      size_t r = alignment % sizeof (void *);
      if (r != 0 || d == 0 || (d & (d - ((size_t) 1))) != 0)
	return 22;
      else if (bytes <=
	       ((-
		 (((sizeof (mchunk)) +
		   (((size_t) (2 * sizeof (void *))) -
		    ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				       ((size_t) 1)))) << 2) - alignment)
	{
	  if (alignment <
	      (((sizeof (mchunk)) +
		(((size_t) (2 * sizeof (void *))) -
		 ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				    ((size_t) 1))))
	    alignment =
	      (((sizeof (mchunk)) +
		(((size_t) (2 * sizeof (void *))) -
		 ((size_t) 1))) & ~(((size_t) (2 * sizeof (void *))) -
				    ((size_t) 1)));
	  mem = internal_memalign ((&_gm_), alignment, bytes);
	}
    }
  if (mem == 0)
    return 12;
  else
    {
      *pp = mem;
      return 0;
    }
}

void *
valloc (size_t bytes)
{
  size_t pagesz;
  (void) (mparams.magic != 0 || init_mparams ());
  pagesz = mparams.page_size;
  return memalign (pagesz, bytes);
}

void *
pvalloc (size_t bytes)
{
  size_t pagesz;
  (void) (mparams.magic != 0 || init_mparams ());
  pagesz = mparams.page_size;
  return memalign (pagesz,
		   (bytes + pagesz - ((size_t) 1)) & ~(pagesz -
						       ((size_t) 1)));
}

void **
independent_calloc (size_t n_elements, size_t elem_size, void *chunks[])
{
  size_t sz = elem_size;
  return ialloc ((&_gm_), n_elements, &sz, 3, chunks);
}

void **
independent_comalloc (size_t n_elements, size_t sizes[], void *chunks[])
{
  return ialloc ((&_gm_), n_elements, sizes, 0, chunks);
}

size_t
bulk_free (void *array[], size_t nelem)
{
  return internal_bulk_free ((&_gm_), array, nelem);
}

#5415 "malloc_.c"
int
malloc_trim (size_t pad)
{
  int result = 0;
  (void) (mparams.magic != 0 || init_mparams ());
  if (!(0))
    {
      result = sys_trim ((&_gm_), pad);
      ;
    }
  return result;
}

size_t
malloc_footprint (void)
{
  return (&_gm_)->footprint;
}

size_t
malloc_max_footprint (void)
{
  return (&_gm_)->max_footprint;
}

size_t
malloc_footprint_limit (void)
{
  size_t maf = (&_gm_)->footprint_limit;
  return maf == 0 ? (~(size_t) 0) : maf;
}

size_t
malloc_set_footprint_limit (size_t bytes)
{
  size_t result;
  if (bytes == 0)
    result =
      (((1) + (mparams.granularity - ((size_t) 1))) & ~(mparams.granularity -
							((size_t) 1)));
  if (bytes == (~(size_t) 0))
    result = 0;
  else
    result =
      (((bytes) +
	(mparams.granularity - ((size_t) 1))) & ~(mparams.granularity -
						  ((size_t) 1)));
  return (&_gm_)->footprint_limit = result;
}


struct mallinfo
mallinfo (void)
{
  return internal_mallinfo ((&_gm_));
}



void
malloc_stats ()
{
  internal_malloc_stats ((&_gm_));
}


int
mallopt (int param_number, int value)
{
  return change_mparam (param_number, value);
}

size_t
malloc_usable_size (void *mem)
{
  if (mem != 0)
    {
      mchunkptr p = ((mchunkptr) ((char *) (mem) - ((sizeof (size_t)) << 1)));
      if ((((p)->head & ((((size_t) 1)) | (((size_t) 2)))) != (((size_t) 1))))
	return ((p)->
		head & ~(((((size_t) 1)) | (((size_t) 2)) | (((size_t) 4)))))
	  -
	  ((((p)->head & ((((size_t) 1)) | (((size_t) 2)))) ==
	    0) ? (((sizeof (size_t)) << 1)) : ((sizeof (size_t))));
    }
  return 0;
}

;
