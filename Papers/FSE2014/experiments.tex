
\section{Experiments}

In order to assess the improvement of our Deep Parameter Tuning approach, we compared our approach with the shallow parameter tuning approach and posed the following research questions: 
 

\begin{description}
 \item[RQ1] {\bf How much improvement can be obtained using the Shallow Parameter Turning approach? }
\end{description}

We asked RQ1 to provide us a baseline results against which to compare the results from our approach. To mimic a traditional Shallow Parameter Turning approach, we used the same NSGAII algorithm introduced in Section \ref{alg} to search for the default explicit parameters for Dlmalloc. To answer this question, we compared the performance of the optimised configuration found by the Shallow Parameter Turning approach with the default Dlmalloc configuration and a set of random generated configurations.  %The default Dlmalloc configuration is chosen by the developer of Dlmalloc and is believed can achieve a good performance on a wide range of programs. We 

\begin{description}
\item[RQ2] {\bf How much more improvement can be obtained using the Deep Parameter Turning approach? }
\end{description}

We ask the RQ2 to see how useful our approach is at find optimised configurations for the given non-functional properties. Our Deep Parameter Turning approach apply NSGAII to optimise both explicit and implicit parameters for Dlmalloc. Of course, should it turn out that the Shallow Parameter Turning approach can find better configuration than our approach, then our approach would not be needed. 

\begin{description}
\item[RQ3] {\bf Do we see evidence that our Deep Parameter Tuning approach can expose implicit parameters which are meaningful to human developer? }
\end{description} 

Should it turn out that the Deep Parameter Tuning approach performs well, achieving much improvement than the Shallow Parameter Tuning approach, then we have evidence to suggest that the mutation based sensitivity analyse used in our approach is able to locate the inner expressions or variables which are sensitive to the given non-functional properties. However, do these inner expressions or variables also make sense to software developer? To answer this research question, we manually investigate the exposed variable and try learn why tuning these parameter can make Dlmalloc more efficient.  

\subsection{Experiment Setup}


\begin{table}[htbp]
\centering
\caption{subject applications}
\label{tab_sub_app}
\resizebox{0.5\textwidth}{!}{
\begin{tabular}{|c|c|c|l|}
\hline
Name & Loc & No. of tests & Type \\
\hline
espresso & 13256 & 19 & Digital electronic gate circuits simplification\\
\hline
cfrac & 6040 & 2 & Big integer factorization\\
\hline
space & 5846 & 3 & Astronautics interpretation\\
\hline
gawk & 45241 & 20 & String processing\\
\hline
\end{tabular}}
\end{table}

For our evaluation, we selected four real world applications: \emph{espresso}, \emph{space}, \emph{cfrac} and \emph{gawk}. \emph{Espresso} is a fast application for simplying complex digital electronic gate circuits and \emph{cfrac} is a factorization application for big integers. We obtain these two applications from the benchmarks of the \emph{DieHard} project\cite{}. \emph{Space} is a well known real world application in astronautics. We obtain this program from the SIR repository \cite{}. \emph{Gawk} is the GNU \emph{awk} implementation for strings processing. We collect this application from the GNU archives \cite{}

Although turning parameter of malloc is less likely to change the behaviour of our subjects under optimise directly, some combination of unusual parameters' values could also crush a subject system. To make sure the configuration generated by our approach always prodcue the same results as the default configuration, we use the number of passed tests as an addtional hard constraints. We used the tests from the \emph{DieHard} project for \emph{Espresso} and \emph{cfrac} and the tests from SIR for \emph{Space}. These tests are designed by programmer and achieve high branche coverage. We mannully generated tests for \emph{awk}, which achieves ** branch coverage. 

All experiments were carried out on a desktop computer with a quad core 3.4GHz CPU and 7.7 GB memory runing 64-bit Ubuntu 13.10. We used \emph{dlmalloc} version 2.8.6 as our base allocator. It was compiled with gcc 4.8.1 with -O3 option. In order to capture the execution time and memory consuming precisly, we adapt developed our own performance tool to measure the CPU time and maxium vitural memory consumption (see Section \label{}) The tool is publicly available at www.fan.put.a.link.later.

